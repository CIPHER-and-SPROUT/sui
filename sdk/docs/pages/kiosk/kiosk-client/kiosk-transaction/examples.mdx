# Examples

Here are some more complete examples on how you'd use the SDK to interact, and we'll focus on dApps.

## Minting into kiosk example

For every scenario when we're using Kiosk in dApps, the user who has connected their wallet will
either have a kiosk already (and could have more than one) or we will have to create it for them.

The SDK supports the scenario of `silently` creating the kiosk, as part of our PTBs.

Let's assume that the mint function of the contract is:

`public fun mint(coin: Coin<SUI>, kiosk: &mut Kiosk, cap: &KioskOwnerCap){...}`

### When the user has a kiosk

```typescript
// let's assume that we have created the client somewhere else.
const kioskClient = new KioskClient({...});
const connectedAddress = '0xAnAddress';

// This function should run when the user connects the wallet.
// We should re-use the same `KioskClient` instance throughout our dApp.
const getCap = async () => {
    let { kioskOwnerCaps } = await kioskClient.getOwnedKiosks(address);
    // let's assume that the user has only 1 kiosk.
    // Here, we would need to do some more checks in a realistic scneario.
    // And also possible give the user in our dApp a selector for which kiosk he wants to interact with (if he owns more than 1).
    return kioskOwnerCaps[0];
}

// The mint function could be like.
const mint = async () => {
    const txb = new TransactionBlock();
    const kioskTx = new KioskTransaction({ kioskClient, txb, cap: await getCap() }});

    // We'll assume it costs 1 SUI
    let coin = txb.splitCoins(txb.gas, [txb.pure(1_000_000_000)]);

    // A function that mints directly into the kiosk.
     txb.moveCall({
            target: '0xMyGame::hero::mint',
            arguments: [
                coin, // the payment
                kioskTx.getKiosk(), // our kiosk that the hero will be placed in.
                kioskTx.getKioskCap() // our kiosk cap, so that the function can place or lock it.
            ]
    });

    kioskTx.wrap();

    // sign and execute transaction block.
    await signAndExecuteTransactionBlock({ tx: txb });
}
```

### When the user doesn't have a kiosk (silent creation)

```typescript
// let's assume that we have created the client somewhere else.
const kioskClient = new KioskClient({...});

// Our mint function.
const mint = async () => {
    const txb = new TransactionBlock();
    const kioskTx = new KioskTransaction({ kioskClient, txb }});

    // creates a kiosk.
    kioskTx.create();

    // We'll assume it costs 1 SUI
    let coin = txb.splitCoins(txb.gas, [txb.pure(1_000_000_000)]);

    // A function that mints directly into the kiosk.
     txb.moveCall({
            target: '0xMyGame::hero::mint',
            arguments: [
                coin, // the payment
                kioskTx.getKiosk(), // our kiosk that the hero will be placed in.
                kioskTx.getKioskCap() // our kiosk cap, so that the function can place or lock it.
            ]
    });

    kioskTx.shareAndTransferCap('0xAddressToTransferCapTo');
    // for new `non-personal` kiosk, we could optionally omit `wrap()`, but it's better to keep it consistent everywhere.
    kioskTx.wrap();

    // sign and execute transaction block.
    await signAndExecuteTransactionBlock({ tx: txb });
}
```

## Borrowing an item from kiosk to do an action

```typescript
// A sample function that borrows an item from kiosk and levels it up.
const levelUp = async (object) => {
	const txb = new TransactionBlock();

	new KioskTransaction({ kioskClient, txb, cap })
		.borrowTx(object, (item) => {
			txb.moveCall({
				target: '0xMyGame::hero::level_up',
				arguments: [item],
			});
		})
		.wrap();

	// sign and execute transaction block.
	await signAndExecuteTransactionBlock({ tx: txb });
};

levelUp({
	itemType: '0x2MyGame::hero::Hero',
	itemId: '0xMyHeroObjectId',
});
```
