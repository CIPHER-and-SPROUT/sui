# Copyright (c) Mysten Labs, Inc.
# SPDX-License-Identifier: Apache-2.0

# Open Questions
# --------------
# - Rules for nullabilit/non-nullability
# - Pattern for multi-gets
# - Encoding RPC errors
# - `type` (vs `scalar`) for Move Types
# - Pattern for upcasting and downcasting

# Check Completeness Against Existing APIs
# -------------
# DONE Read
# DONE - Objects
# DONE - Transactions
# DONE - Checkpoints
# DONE - Events
# DONE - ProtocolConfig
# DONE - Chain Identifier
# DONE Coin
# DONE Extended
# DONE Governance
# DONE Indexer
# DONE Move Utils
# TODO Write

# DONE Port designs from Notion
# DONE - Display
# DONE - SuiNS
# DONE Data Consistency API
# TODO Flesh out Connections
# TODO - TotalTransactionBlocks for the PTB connection

schema {
  query: Query
  subscription: Subscription
}

type Query {
  # First four bytes of the network's genesis checkpoint digest
  # (uniquely defines the network)
  chainIdentifier: String!

  # First and last checkpoint that the RPC can answer consistent
  # queries for.
  consistentRange: ConsistentRange

  owner(address: SuiAddress!): Owner
  object(address: SuiAddress!, version: BigInt): Object
  address(address: SuiAddress!): Address

  epoch(epochId: Int): Epoch
  protocolConfig(protocolVersion: Int): ProtocolConfig

  checkpoint(filter: CheckpointFilter): Checkpoint
  checkpointsConnection(cursor: String!, count: Int!, order: Order!): CheckpointConnection

  transactionBlock(digest: Bytes!): TransactionBlock
  transactionBlocksConnection(cursor: String!, count: Int!, order: Order!): TransactionBlockConnection

  coinMetadata(coinType: String!): CoinMetadata

  queryObjectsConnection(cursor: String!, count: Int!, order: Order!, query: ObjectQuery): ObjectQueryConnection
  queryEventsConnection(cursor: String!, count: Int!, order: Order!, filter: EventFilter, order: Order!): EventQueryConnection
  queryTransactionBlocksConnection(
    cursor: String!, count: Int!, order: Order!,
    filter: TransactionBlockFilter,
    order: Order!,
  ): TransactionBlockQueryConnection

  resolveNameServiceAddress(name: String!): Address

  networkMetrics: NetworkMetrics
  moveCallMetrics: MoveCallMetrics
  checkpointAddressMetrics(checkpoint: BigInt): AddressMetric
  allEpochAddressMetricsConnection(cursor: String!, count: Int!, order: Order!): AddressMetricConnection
}

type Subscription {
  events(filter: EventFilter): Event
  transactions(filter: TransactionBlockFilter): TransactionBlock
}

# String containing 32B hex-encoded address
scalar SuiAddress

# String representation of an arbitrary width, possibly signed integer
scalar BigInt

# String containing Base58-encoded binary data.
scalar Bytes

# Filter either by the digest, or the sequence number, or neither, to
# get the latest checkpoint.
input CheckpointFilter {
  digest: Bytes
  sequenceNumber: BigInt
}

enum Order { ASC, DESC }

input ObjectQuery {
  # one of these
  any: [ObjectQuery]
  all: [ObjectQuery]
  not: ObjectQuery

  # (x)or any of these

  # Cascading (type requires module requires package)
  package: SuiAddress
  module: String
  type: String

  owner: SuiAddress
  objectId: SuiAddress
  version: BigInt
}

input EventFilter {
  # one of these
  any: [EventFilter]
  all: [EventFilter]
  not: EventFilter

  # (x)or any of these
  sender: SuiAddress
  transactionDigest: Bytes

  # Cascading (module requires package)
  emittingPackage: SuiAddress
  emittingModule: String

  # Cascading (type requires module requires package)
  eventPackage: SuiAddress
  eventModule: String
  eventType: String

  eventField: EventField

  startTimeMs: BigInt
  endTimeMs: BigInt
}

input EventField {
  path: String!
  json: String!
}

input TransactionBlockFilter {
  # one of these
  any: [TransactionBlockFilter]
  all: [TransactionBlockFilter]
  not: TransactionBlockFilter

  # (x)or any of these

  # Cascading (function requires module requires package)
  package: SuiAddress
  module: String
  function: String

  kind: TransactionBlockKindInput
  checkpoint: BigInt
  fromAddress: SuiAddress
  toAddress: SuiAddress

  inputObject: SuiAddress
  changedObject: SuiAddress
}

type ConsistentRange {
  first: Checkpoint
  last: Checkpoint
}

interface Owner {
  location: SuiAddress!

  objectsConnection(cursor: String!, count: Int!, order: Order!, query: ObjectQuery): ObjectQueryConnection

  balance(type: String!): Balance
  balancesConnection(cursor: String!, count: Int!, order: Order!): BalanceConnection

  coinsConnection(cursor: String!, count: Int!, order: Order!, type: String): CoinConnection

  stakesConnection(cursor: String!, count: Int!, order: Order!): StakeConnection

  defaultNameServiceName: String
  nameServiceNamesConnection(cursor: String!, count: Int!, order: Order!): NameServiceNamesConnection
}

# Returned by Object.owner, where we can't disambiguate between
# Address and Object.
type AmbiguousOwner implements Owner {}

type Address implements Owner {
  transactionBlocksConnection(
    cursor: String!, count: Int!, order: Order!,
    filter: AddressTransactionBlockFilter,
  ): TransactionBlockConnection
}

enum AddressTransactionBlockFilter {
  SIGN # Transactions this address has signed
  SENT # Transactions that transferred objects from this address
  RECV # Transactions that received objects into this address
  PAID # Transactions that were paid for by this address
}

type Object implements Owner {
  owner: AmbiguousOwner
  version: BigInt
  digest: Bytes

  previousVersion: BigInt
  previousTransactionBlock: TransactionBlock
  storageRebate: BigInt

  display: [DisplayEntry!]

  asMoveObject: MoveObject
  asMovePackage: MovePackage

  # Transaction Blocks that sent objects to this object
  receivedTransactionBlocksConnection(cursor: String!, count: Int!, order: Order!): TransactionBlockConnection

  dynamicField(dynamicFieldName: DynamicFieldName!): DynamicField
  dynamicFieldsConnection(cursor: String!, count: Int!, order: Order!): DynamicFieldConnection

  bcs: Bytes
}

type DisplayEntry {
  key: String!
  value: String!
}

type Epoch {
  epochId: Int!
  systemStateVersion: Int
  protocolConfigs: ProtocolConfigs
  referenceGasPrice: BigInt

  systemParameters: SystemParameters
  stakeSubsidy: StakeSubsidy
  validatorSet: ValidatorSet
  storageFund: StorageFund
  safeMode: SafeMode

  startTimestampMs: BigInt
  endTimestampMs: BigInt

  # TODO: Identify non-duplicate fields in `EndOfEpochInfo`

  checkpointsConnection(cursor: String!, count: Int!, order: Order!): CheckpointConnection
  transactionBlocksConnection(cursor: String!, count: Int!, order: Order!): TransactionBlockConnection
}

type ProtocolConfigs {
  protocolVersion: Int!
  configs: [ProtocolConfig]
  config(key: String!): ProtocolConfig
}

type ProtocolConfig {
  key: String!
  value: String!
}

type SystemParameters {
  durationMs: BigInt
  stakeSubsidyStartEpoch: Int

  minValidatorCount: Int
  maxValidatorCount: Int

  minValidatorJoiningStake: BigInt
  validatorLowStakeThreshold: BigInt
  validatorVeryLowStakeThreshold: BigInt
  validatorLowStakeGracePeriod: Int
}

type StakeSubsidy {
  balance: BigInt
  distributionCounter: BigInt
  currentDistributionAmount: BigInt
  periodLength: Int
  decreaseRate: Int
}

type ValidatorSet {
  totalStake: BigInt

  activeValidators: [Validator]

  # Indices into `activeValidators`
  pendingRemovals: [BigInt]

  pendingActiveValidators: MoveObject
  pendingActiveValidatorsSize: BigInt

  stakePoolMappings: MoveObject
  stakePoolMappingsSize: BigInt

  inactivePools: MoveObject
  inactivePoolsSize: BigInt

  validatorCandidates: MoveObject
  validatorCandidatesSize: BigInt
}

type Validator {
  address: Address!

  credentials: ValidatorCredentials
  nextEpochCredentials: ValidatorCredentials

  name: String
  description: String
  imageUrl: String
  projectUrl: String

  operationCap: MoveObject
  stakingPool: MoveObject
  exchangeRates: MoveObject

  stakingPoolActivationEpoch: Int
  stakingPoolSuiBalance: BigInt
  rewardsPool: BigInt
  poolTokenBalance: BigInt
  pendingStake: BigInt
  pendingTotalSuiWithdraw: BigInt
  pendingPoolTokenWithdraw: BigInt
  exchangeRatesSize: BigInt

  votingPower: Int
  stakeUnits: Int
  gasPrice: BigInt
  commissionRate: BigInt
  nextEpochStake: BigInt
  nextEpochGasPrice: BigInt
  nextEpochCommissionRate: BigInt

  # The number of epochs for which this validator has been below the
  # low stake threshold.
  atRisk: Int

  # The other validators this validator has reported
  reportRecords: [SuiAddress]

  apy: Float
}

type ValidatorCredentials {
  protocolPubKey: Bytes
  networkPubKey: Bytes
  workerPubKey: Bytes
  proofOfPossession: Bytes

  netAddress: String
  p2pAddreess: String
  primaryAddress: String
  workerAddress: String
}

type StorageFund {
  totalObjectStorageRebates: BigInt
  nonRefundableBalance: BigInt
}

type SafeMode {
  enabled: Boolean
  gasSummary: GasCostSummary
}

type Checkpoint {
  id: ID!
  digest: Bytes!
  sequenceNumber: BigInt!
  timestampMs: BigInt
  validatorSignature: Bytes

  # Commitments
  previousCheckpointDigest: Bytes
  liveObjectSetDigest: Bytes

  networkTotalTransactions: BigInt
  rollingGasSummary: GasCostSummary

  epoch: Epoch

  # Only available on the final checkpoint in an epoch
  endOfEpoch: EndOfEpochData

  transactionsConnection(cursor: String!, count: Int!, order: Order!): TransactionBlockConnection
}

type EndOfEpochData {
  newCommittee: [CommitteeMember]
  nextProtocolVersion: Int
}

type CommitteeMember {
  authorityName: String
  stakeUnit: Int
}

type TransactionBlock {
  digest: Bytes!
  sender: Address
  gasInput: GasInput
  kind: TransactionBlockKind
  signatures: [TransactionSignature]
  effects: TransactionBlockEffects

  expiration: Epoch

  bcs: Bytes
}

enum TransactionBlockKindInput {
  CONSENSUS_COMMIT_PROLOGUE
  GENESIS
  CHANGE_EPOCH
  PROGRAMMABLE
}

union TransactionBlockKind =
    ConsensusCommitPrologueTransaction
  | GenesisTransaction
  | ChangeEpochTransaction
  | ProgrammableTransactionBlock

type ConsensusCommitPrologueTransaction {
  epoch: Epoch
  # TODO: This is the "leader round" -- does this line up with
  # checkpoints? In which case, it may suffice to have a `Checkpoint`
  # here.
  round: BigInt
  timestampMs: BigInt
}

type GenesisTransaction {
  objects: [Object]
}

type ChangeEpochTransaction {
  epoch: Epoch
  timestampMs: BigInt

  storageCharge: BigInt
  computationCharge: BigInt
  storageRebate: BigInt
}

type ProgrammableTransactionBlock {
  inputs: [TransactionInput]
  transactions: [ProgrammableTransaction]
}

union TransactionInput = MovePackage | MoveObject | ShareInput

type SharedInput {
  id: SuiAddress
  initialSharedVersion: BigInt
  mutable: Boolean
}

union TransactionArgument = GasCoin | Input | Result

type GasCoin {}
type Input   { ix: Int }
type Result  { cmd: Int, ix: Int }

union ProgrammableTransaction =
    MoveCallTransaction
  | TransferObjectsTransaction
  | SplitCoinTransaction
  | MergeCoinsTransaction
  | PublishTransaction
  | UpgradeTransaction
  | MakeMoveVecTransaction

type MoveCallTransaction {
  moduleId: MoveModuleId
  name: String
  function: NormalizedFunction

  typeArguments: [MoveType]
  arguments: [TransactionArgument]
}

type TransferObjectsTransaction {
  objects: [TransactionArgument]
  address: TransactionArgument
}

type SplitCoinTransaction {
  coin: TransactionArgument
  amounts: [TransactionArgument]
}

type MergeCoinsTransaction {
  coin: TransactionArgument
  coins: [TransactionArgument]
}

type PublishTransaction {
  dependencies: [MovePackage]
}

type UpgradeTransaction {
  dependencies: [MovePackage]
  currentPackage: MovePackage
  upgradeTicket: TransactionArgument
}

type MakeMoveVecTransaction {
  type: MoveType
  elements: [TransactionArgument]
}

# Omitting for brevity -- there's a lot of structure here, but it's
# not very "connected" (i.e. no edges to other types).
type TransactionSignature {}

type TransactionBlockEffects {
  digest: Bytes!
  status: ExecutionStatus!
  errors: String
  transactionBlock: TransactionBlock
  dependencies: [TransactionBlock]

  lamportVersion: BigInt
  gasEffects: GasEffects
  objectReads: [Object]
  objectChanges: [ObjectChange]
  balanceChanges: [BalanceChange]

  epoch: Epoch
  checkpoint: Checkpoint

  eventsConnection(cursor: String!, count: Int!, order: Order!): TransactionEventConnection

  bcs: Bytes
}

enum ExecutionStatus {
  SUCCESS
  FAILURE
}

type GasInput {
  gasSponsor: Address
  gasPayment: [Object]

  gasPrice: BigInt
  gasBudget: BigInt
}

type GasEffects {
  gasObject: Coin
  gasSummary: GasCostSummary
}

type GasCostSummary {
  computationCost: BigInt
  storageCost: BigInt
  storageRebate: BigInt
  nonRefundableStorageFee: BigInt
}

type ObjectChange {
  inputState: Object
  outputState: Object

  idCreated: Boolean
  idDeleted: Boolean
}

type BalanceChange {
  owner: Owner
  coinType: MoveType
  amount: BigInt
}

type Event {
  moduleId: MoveModuleId
  type: MoveType
  sender: Address
  timestampMs: BigInt

  json: String
  bcs: Bytes
}

type Balance {
  id: ID!
  coinType: MoveType
  coinObjectCount: BigInt
  totalBalance: BigInt
}

type Coin {
  id: ID!
  balance: BigInt
  asMoveObject: MoveObject
}

type StakedSui {
  status: StakeStatus
  requestEpoch: Epoch
  activeEpoch: Epoch
  principal: BigInt

  # Only available if status is `ACTIVE`.
  estimatedReward: BigInt

  asMoveObject: MoveObject
}

enum StakeStatus {
  PENDING
  ACTIVE
  UNSTAKED
}

type CoinMetadata {
  decimals: Int
  name: String
  symbol: String
  description: String
  iconURL: String
  supply: BigInt

  asMoveObject: MoveObject
}

input DynamicFieldName {
  type: String!
  bcs: Bytes!
}

type DynamicField {
  name: MoveValue
  value: DynamicFieldValue
}

union DynamicFieldValue = MoveObject | MoveValue

type MoveObject {
  contents: MoveValue
  hasPublicTransfer: Boolean

  asCoin: Coin
  asStakedSui: StakedSui
  asObject: Object
}

type MovePackage {
  modulesConnection(cursor: String!, count: Int!, order: Order!): MovePackageModuleConnection

  normalizedModulesConnection(cursor: String!, count: Int!, order: Order!): NormalizedModulesConnection
  normalizedModule(name: String!): NormalizedModule

  asObject: Object
}

type MoveModuleId {
  package: MovePackage
  name: String
}

enum MoveAbility {
  COPY
  DROP
  STORE
  KEY
}

enum MoveVisibility {
  PUBLIC
  PRIVATE
  FRIEND
}

enum MoveReference {
  IMMUT
  MUT
}

type MoveStructTypeParameterDecl {
  constraints: [MoveAbility]
  isPhantom: Boolean
}

type MoveFunctionTypeParameterDecl {
  constraints: [MoveAbility]
}

type NormalizedModule {
  fileFormatVersion: Int

  moduleId: MoveModuleId
  friends: [MoveModuleId]

  structsConnection(cursor: String!, count: Int!, order: Order!): NormalizedStructConnection
  struct(name: String!): NormalizedStruct

  functionsConnection(cursor: String!, count: Int!, order: Order!): NormalizedFunctionConnection
  function(name: String!): NormalizedFunction
}

type NormalizedStruct {
  module: NormalizedModule
  name: String

  abilities: [MoveAbility]
  typeParameters: [MoveStructTypeParameterDecl]
  fields: [NormalizedField]
}

type NormalizedField {
  name: String
  type: MoveTypeUse
}

type NormalizedFunction {
  module: NormalizedModule
  name: String

  visibility: MoveVisibility
  isEntry: Boolean

  typeParameters: [MoveFunctionTypeParameterDecl]
  parameters: [MoveTypeUse]
  return: [MoveTypeUse]
}

type MoveValue {
  type: MoveType!
  data: MoveData

  bcs: Bytes
}

union MoveData =
    MoveNumber
  | MoveBool
  | MoveAddress
  | MoveUID
  | MoveString
  | MoveVector
  | MoveOption
  | MoveStruct

type MoveNumber  { number: String! }
type MoveBool    { bool: Boolean! }
type MoveAddress { address: SuiAddress! }
type MoveUID     { uid: SuiAddress! }
type MoveString  { string: String! }
type MoveVector  { elements: [MoveValue!]! }
type MoveOption  { element: MoveValue }
type MoveStruct  { fields: [MoveField!]! }

type MoveField {
  name: String!
  value: MoveValue!
}

type MoveTypeName {
  # Fully qualified type name.  Primitive types have no `moduleId`, or
  # `struct`.
  moduleId: MoveModuleId
  name: String!
  struct: NormalizedStruct
}

type MoveType {
  # Scalar representation of the type instantiation (type and type
  # parameters)
  repr: String!
  typeName: MoveTypeName!
  typeParameters: [MoveType]
}

type MoveTypeUse {
  repr: String!
  ref: MoveReference
  type: MoveTypeBody
}

union MoveTypeBody = MoveTypeNameUse | MoveTypeParameterUse

type MoveTypeNameUse {
  name: MoveTypeName!
  typeParameters: [MoveTypeUse]
}

type MoveTypeParameterUse {
  index: Int
}

# Metrics (omitted for brevity)
type NetworkMetrics {}
type MoveCallMetrics {}
type AddressMetrics {}

# Connections

type AddressMetricConnection {}
type DynamicFieldConnection {}
type EventQueryConnection {}
type MovePackageModuleConnection {}
type NameServiceNamesConnection {}
type NormalizedFunctionConnection {}
type NormalizedModuleConnection {}
type NormalizedStructConnection {}
type ObjectQueryConnection {}
type StakeConnection {}
type TransactionBlockConnection {}
type TransactionBlockQueryConnection {}
type TransactionEventConnection {}

# Pagination
type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
}

# Checkpoints
type CheckpointConnection {
  edges: [CheckpointEdge!]!
  pageInfo: PageInfo!
}

type CheckpointEdge {
  cursor: String
  node: Checkpoint!
}

# Balance
type BalanceConnection {
  edges: [BalanceEdge!]!
  pageInfo: PageInfo!
}

type BalanceEdge {
  cursor: String
  node: Balance!
}

# Coin
type CoinConnection {
  edges: [CoinEdge!]!
  pageInfo: PageInfo!
}

type CoinEdge {
  cursor: String
  node: Coin!
}
