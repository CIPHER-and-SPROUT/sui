# Copyright (c) Mysten Labs, Inc.
# SPDX-License-Identifier: Apache-2.0

# Open Questions
# --------------
# - Pattern for multi-gets
# - Encoding RPC errors
# - `type` (vs `scalar`) for Move Types
# - Pattern for upcasting and downcasting
# - Subscription APIs

# Check Completeness Against Existing APIs
# -------------
# TODO Read
# DONE - Objects
# DONE - Transactions
# DONE - Checkpoints
# DONE - Events
# TODO - ProtocolConfig
# TODO - Chain Identifier
# TODO Coin
# TODO Extended
# TODO Governance
# TODO Indexer
# TODO Move Utils
# TODO Write

# TODO Port designs from Notion
# TODO - Display
# TODO - SuiNS
# TODO Data Consistency API
# TODO Flesh out Connections
# TODO - TotalTransactionBlocks for the PTB connection

schema {
  query: Query
}

type Query {
  owner(address: SuiAddress!): Owner
  object(address: SuiAddress!, version: U64): Object
  address(address: SuiAddress!): Address

  checkpoint(filter: CheckpointFilter): Checkpoint
  checkpoints(): CheckpointConnection

  transactionBlock(digest: Digest!): TransactionBlock
  transactionBlocks(): TransactionBlockConnection
}

# String containing 32B hex-encoded address
scalar SuiAddress

# String containing 32B Base58-encoded BLAKE2b256 digest
scalar Digest

# String representation of a 64 bit unsigned integer
scalar U64

# String representation of a 128 bit signed integer
scalar I128

# String containing Base58-encoded binary data.
scalar Bytes

scalar JSON

# Filter either by the digest, or the sequence number, or neither, to
# get the latest checkpoint.
input CheckpointFilter {
  digest: Digest
  sequenceNumber: U64
}

interface Owner {
  id: SuiAddress!
}

# Returned by Object.owner, where we can't disambiguate between
# Address and Object.
type AmbiguousOwner implements Owner {}

type Address implements Owner {
  transactionBlocks(
    filter: AddressTransactionBlockFilter,
  ): TransactionBlockConnection
}

enum AddressTransactionBlockFilter {
  SIGN # Transactions this address has signed
  SENT # Transactions that transferred objects from this address
  RECV # Transactions that received objects into this address
  PAID # Transactions that were paid for by this address
}

type Object implements Owner {
  owner: Owner
  version: U64
  digest: Digest

  previousVersion: U64
  previousTransactionBlock: TransactionBlock
  storageRebate: U64

  asMoveObject: MoveObject
  asMovePackage: MovePackage

  # Transaction Blocks that sent objects to this object
  receivedTransactionBlocks: TransactionBlockConnection

  bcs: Bytes
}

type Epoch {}

type Checkpoint {
  digest: Digest!
  sequenceNumber: U64!
  timestampMs: U64
  validatorSignature: Bytes

  # Commitments
  previousCheckpoint: Digest
  liveObjectSet: Digest

  networkTotalTransactions: U64
  rollingGasCostSummary: GasCostSummary

  epoch: Epoch

  # Only available on the final checkpoint in an epoch
  endOfEpoch: EndOfEpochData

  transactions: TransactionBlockConnection
}

type EndOfEpochData {
  newCommittee: [CommitteeMember]
  nextProtocolVersion: Int
}

type CommitteeMember {
  authorityName: String
  stakeUnit: Int
}

type TransactionBlock {
  digest: Digest!
  sender: Address
  gasInput: GasInput
  kind: TransactionBlockKind
  signatures: [TransactionSignature]
  effects: TransactionBlockEffects

  expiration: Epoch

  bcs: Bytes
}

union TransactionBlockKind =
    ConsensusCommitPrologueTransaction
  | GenesisTransaction
  | ChangeEpochTransaction
  | ProgrammableTransactionBlock

type ConsensusCommitPrologueTransaction {
  epoch: Epoch
  # TODO: This is the "leader round" -- does this line up with
  # checkpoints? In which case, it may suffice to have a `Checkpoint`
  # here.
  round: U64
  timestampMs: U64
}

type GenesisTransaction {
  objects: [Object]
}

type ChangeEpochTransaction {
  epoch: Epoch
  timestampMs: U64

  storageCharge: U64
  computationCharge: U64
  storageRebate: U64
}

type ProgrammableTransactionBlock {
  inputs: [TransactionInput]
  transactions: [ProgrammableTransaction]
}

union TransactionInput = MovePackage | MoveObject | ShareInput

type SharedInput {
  id: SuiAddress
  initialSharedVersion: U64
  mutable: Boolean
}

union TransactionArgument = GasCoin | Input | Result

type GasCoin {}
type Input   { ix: Int }
type Result  { cmd: Int, ix: Int }

union ProgrammableTransaction =
    MoveCallTransaction
  | TransferObjectsTransaction
  | SplitCoinTransaction
  | MergeCoinsTransaction
  | PublishTransaction
  | UpgradeTransaction
  | MakeMoveVecTransaction

type MoveCallTransaction {
  package: MovePackage
  module: String
  function: String

  typeArguments: [MoveType]
  arguments: [TransactionArgument]
}

type TransferObjectsTransaction {
  objects: [TransactionArgument]
  address: TransactionArgument
}

type SplitCoinTransaction {
  coin: TransactionArgument
  amounts: [TransactionArgument]
}

type MergeCoinsTransaction {
  coin: TransactionArgument
  coins: [TransactionArgument]
}

type PublishTransaction {
  dependencies: [MovePackage]
}

type UpgradeTransaction {
  dependencies: [MovePackage]
  currentPackage: MovePackage
  upgradeTicket: TransactionArgument
}

type MakeMoveVecTransaction {
  type: MoveType
  elements: [TransactionArgument]
}

# Omitting for brevity -- there's a lot of structure here, but it's
# not very "connected" (i.e. no edges to other types).
type TransactionSignature {}

type TransactionBlockEffects {
  digest: Digest!
  status: ExecutionStatus!
  errors: String
  transactionBlock: TransactionBlock
  dependencies: [TransactionBlock]

  lamportVersion: U64
  gasEffects: GasEffects
  objectReads: [Object]
  objectChanges: [ObjectChange]
  balanceChanges: [BalanceChange]

  epoch: Epoch
  checkpoint: Checkpoint

  events: TransactionEventConnection

  bcs: Bytes
}

enum ExecutionStatus {
  SUCCESS
  FAILURE
}

type GasInput {
  gasSponsor: Address
  gasPayment: [Object] # TODO Specialise to Coin type

  gasPrice: U64
  gasBudget: U64
}

type GasEffects {
  gasObject: Object # TODO Specialise to Coin type
  costSummary: GasCostSummary
}

type GasCostSummary {
  computationCost: U64
  storageCost: U64
  storageRebate: U64
  nonRefundableStorageFee: U64
}

type ObjectChange {
  inputState: Object
  outputState: Object

  idCreated: Boolean
  idDeleted: Boolean
}

type BalanceChange {
  owner: Owner
  coinType: MoveType
  amount: I128
}

type Event {
  package: MovePackage
  module: String
  sender: Address
  type: MoveType
  timestampMs: U64

  json: JSON
  bcs: Bytes
}

type MoveObject {
  contents: MoveValue
  hasPublicTransfer: Boolean

  asObject: Object
}

type MovePackage {
  modules: MovePackageModuleConnection

  asObject: Object
}

type MoveValue {
  type: MoveType!
  data: MoveData

  bcs: Bytes
}

union MoveData =
    MoveNumber
  | MoveBool
  | MoveAddress
  | MoveUID
  | MoveString
  | MoveVector
  | MoveOption
  | MoveStruct

type MoveNumber  { number: String! }
type MoveBool    { bool: Boolean! }
type MoveAddress { address: SuiAddress! }
type MoveUID     { uid: SuiAddress! }
type MoveString  { string: String! }
type MoveVector  { elements: [MoveValue!]! }
type MoveOption  { element: MoveValue }
type MoveStruct  { fields: [MoveField!]! }

type MoveField {
  name: String!
  value: MoveValue!
}

type MoveType {
  # Flattened representation of the type and type parameters
  repr: String!

  # Fully qualified type name.  Primitive types have no `package` or
  # `module`.
  package: MovePackage
  module: String
  name: String!

  typeParameters: [MoveType]
}

# Connections

type CheckpointConnection {}
type MovePackageModuleConnection {}
type TransactionBlockConnection {}
type TransactionEventConnection {}
