# Copyright (c) Mysten Labs, Inc.
# SPDX-License-Identifier: Apache-2.0

# Open Questions
# --------------
# - Rules for nullabilit/non-nullability
# - Pattern for multi-gets
# - Encoding RPC errors
# - `type` (vs `scalar`) for Move Types
# - Pattern for upcasting and downcasting

# Check Completeness Against Existing APIs
# -------------
# DONE Read
# DONE - Objects
# DONE - Transactions
# DONE - Checkpoints
# DONE - Events
# DONE - ProtocolConfig
# DONE - Chain Identifier
# DONE Coin
# DONE Extended
# DONE Governance
# DONE Indexer
# DONE Move Utils
# TODO Write

# DONE Port designs from Notion
# DONE - Display
# DONE - SuiNS
# DONE Data Consistency API
# TODO Flesh out Connections
# TODO - TotalTransactionBlocks for the PTB connection

schema {
  query: Query
  subscription: Subscription
}

type Query {
  # First four bytes of the network's genesis checkpoint digest
  # (uniquely defines the network)
  chainIdentifier: String!

  # First and last checkpoint that the RPC can answer consistent
  # queries for.
  consistentRange: ConsistentRange

  owner(address: SuiAddress!): Owner
  object(address: SuiAddress!, version: U64): Object
  address(address: SuiAddress!): Address

  epoch(epochId: Int): Epoch
  protocolConfig(protocolVersion: Int): ProtocolConfig

  checkpoint(filter: CheckpointFilter): Checkpoint
  checkpoints(order: Order!): CheckpointConnection

  transactionBlock(digest: Digest!): TransactionBlock
  transactionBlocks: TransactionBlockConnection

  coinMetadata(coinType: TypeInst!): CoinMetadata

  queryObjects(query: ObjectQuery): ObjectQueryConnection
  queryEvents(filter: EventFilter, order: Order!): EventQueryConnection
  queryTransactionBlocks(
    filter: TransactionBlockFilter,
    order: Order!,
  ): TransactionBlockQueryConnection

  resolveNameServiceAddress(name: String!): SuiAddress

  networkMetrics: NetworkMetrics
  moveCallMetrics: MoveCallMetrics
  checkpointAddressMetrics(checkpoint: U64): AddressMetric
  allEpochAddressMetrics(order: Order!): AddressMetricConnection
}

type Subscription {
  events(filter: EventFilter): Event
  transactions(filter: TransactionBlockFilter): TransactionBlock
}

# String containing 32B hex-encoded address
scalar SuiAddress

# String containing 32B Base58-encoded BLAKE2b256 digest
scalar Digest

# String representation of a 64 bit unsigned integer
scalar U64

# String representation of a 128 bit signed integer
scalar I128

# String representation of a 128 bit unsigned integer
scalar U128

# String containing Base58-encoded binary data.
scalar Bytes

scalar JSON

# Fully qualified concrete type instantiation, with a flat
# representation:
#
# ([package]::[module]::)?[name](<[param], ...>)?.
scalar TypeInst

# Move type from a function (parameter or return type) or struct
# (field) signature.  May contain type parameters, referred to by
# index.
scalar TypeSignature

# Filter either by the digest, or the sequence number, or neither, to
# get the latest checkpoint.
input CheckpointFilter {
  digest: Digest
  sequenceNumber: U64
}

enum Order { ASC, DESC }

input ObjectQuery {
  # one of these
  any: [ObjectQuery]
  all: [ObjectQuery]
  not: ObjectQuery

  # (x)or any of these

  # Cascading (type requires module requires package)
  package: SuiAddress
  module: String
  type: String

  owner: SuiAddress
  objectId: SuiAddress
  version: U64
}

input EventFilter {
  # one of these
  any: [EventFilter]
  all: [EventFilter]
  not: EventFilter

  # (x)or any of these
  sender: SuiAddress
  transaction: Digest

  # Cascading (module requires package)
  emittingPackage: SuiAddress
  emittingModule: String

  # Cascading (type requires module requires package)
  eventPackage: SuiAddress
  eventModule: String
  eventType: String

  eventField: EventField

  startTimeMs: U64
  endTimeMs: U64
}

input EventField {
  path: String!
  value: JSON!
}

input TransactionBlockFilter {
  # one of these
  any: [TransactionBlockFilter]
  all: [TransactionBlockFilter]
  not: TransactionBlockFilter

  # (x)or any of these

  # Cascading (function requires module requires package)
  package: SuiAddress
  module: String
  function: String

  kind: TransactionBlockKindInput
  checkpoint: U64
  fromAddress: SuiAddress
  toAddress: SuiAddress

  inputObject: SuiAddress
  changedObject: SuiAddress
}

type ConsistentRange {
  first: Checkpoint
  last: Checkpoint
}

interface Owner {
  id: SuiAddress!

  objects(query: ObjectQuery): ObjectQueryConnection

  balance(type: TypeInst!): Balance
  balances: BalanceConnection

  coins(type: TypeInst): CoinConnection

  stakes: StakeConnection

  defaultNameServiceName: String
  nameServiceNames: NameServiceNamesConnection
}

# Returned by Object.owner, where we can't disambiguate between
# Address and Object.
type AmbiguousOwner implements Owner {}

type Address implements Owner {
  transactionBlocks(
    filter: AddressTransactionBlockFilter,
  ): TransactionBlockConnection
}

enum AddressTransactionBlockFilter {
  SIGN # Transactions this address has signed
  SENT # Transactions that transferred objects from this address
  RECV # Transactions that received objects into this address
  PAID # Transactions that were paid for by this address
}

type Object implements Owner {
  owner: AmbiguousOwner
  version: U64
  digest: Digest

  previousVersion: U64
  previousTransactionBlock: TransactionBlock
  storageRebate: U64

  display: [DisplayEntry]

  asMoveObject: MoveObject
  asMovePackage: MovePackage

  # Transaction Blocks that sent objects to this object
  receivedTransactionBlocks: TransactionBlockConnection

  dynamicField(dynamicFieldName: DynamicFieldName!): DynamicField
  dynamicFields: DynamicFieldConnection

  bcs: Bytes
}

type DisplayEntry {
  key: String
  value: String
}

type Epoch {
  epochId: Int!
  systemStateVersion: Int
  protocolConfig: ProtocolConfig
  referenceGasPrice: U64

  systemParameters: SystemParameters
  stakeSubsidy: StakeSubsidy
  validatorSet: ValidatorSet
  storageFund: StorageFund
  safeMode: SafeMode

  startTimestampMs: U64
  endTimestampMs: U64

  # TODO: Identify non-duplicate fields in `EndOfEpochInfo`

  checkpoints: CheckpointConnection
  transactionBlocks: TransactionBlockConnection
}

type ProtocolConfig {
  protocolVersion: Int!
  # Omitting for brevity
}

type SystemParameters {
  durationMs: U64
  stakeSubsidyStartEpoch: Int

  minValidatorCount: Int
  maxValidatorCount: Int

  minValidatorJoiningStake: U64
  validatorLowStakeThreshold: U64
  validatorVeryLowStakeThreshold: U64
  validatorLowStakeGracePeriod: Int
}

type StakeSubsidy {
  balance: U64
  distributionCounter: U64
  currentDistributionAmount: U64
  periodLength: Int
  decreaseRate: Int
}

type ValidatorSet {
  totalStake: U64

  activeValidators: [Validator]

  # Indices into `activeValidators`
  pendingRemovals: [U64]

  pendingActiveValidators: MoveObject
  pendingActiveValidatorsSize: U64

  stakePoolMappings: MoveObject
  stakePoolMappingsSize: U64

  inactivePools: MoveObject
  inactivePoolsSize: U64

  validatorCandidates: MoveObject
  validatorCandidatesSize: U64
}

type Validator {
  address: Address!

  credentials: ValidatorCredentials
  nextEpochCredentials: ValidatorCredentials

  name: String
  description: String
  imageUrl: String
  projectUrl: String

  operationCap: MoveObject
  stakingPool: MoveObject
  exchangeRates: MoveObject

  stakingPoolActivationEpoch: Int
  stakingPoolSuiBalance: U64
  rewardsPool: U64
  poolTokenBalance: U64
  pendingStake: U64
  pendingTotalSuiWithdraw: U64
  pendingPoolTokenWithdraw: U64
  exchangeRatesSize: U64

  votingPower: Int
  stakeUnits: Int
  gasPrice: U64
  commissionRate: U64
  nextEpochStake: U64
  nextEpochGasPrice: U64
  nextEpochCommissionRate: U64

  # The number of epochs for which this validator has been below the
  # low stake threshold.
  atRisk: Int

  # The other validators this validator has reported
  reportRecords: [SuiAddress]

  apy: Float
}

type ValidatorCredentials {
  protocolPubKey: Bytes
  networkPubKey: Bytes
  workerPubKey: Bytes
  proofOfPossession: Bytes

  netAddress: String
  p2pAddreess: String
  primaryAddress: String
  workerAddress: String
}

type StorageFund {
  totalObjectStorageRebates: U64
  nonRefundableBalance: U64
}

type SafeMode {
  enabled: Boolean
  gasSummary: GasCostSummary
}

type Checkpoint {
  digest: Digest!
  sequenceNumber: U64!
  timestampMs: U64
  validatorSignature: Bytes

  # Commitments
  previousCheckpoint: Digest
  liveObjectSet: Digest

  networkTotalTransactions: U64
  rollingGasSummary: GasCostSummary

  epoch: Epoch

  # Only available on the final checkpoint in an epoch
  endOfEpoch: EndOfEpochData

  transactions: TransactionBlockConnection
}

type EndOfEpochData {
  newCommittee: [CommitteeMember]
  nextProtocolVersion: Int
}

type CommitteeMember {
  authorityName: String
  stakeUnit: Int
}

type TransactionBlock {
  digest: Digest!
  sender: Address
  gasInput: GasInput
  kind: TransactionBlockKind
  signatures: [TransactionSignature]
  effects: TransactionBlockEffects

  expiration: Epoch

  bcs: Bytes
}

enum TransactionBlockKindInput {
  CONSENSUS_COMMIT_PROLOGUE
  GENESIS
  CHANGE_EPOCH
  PROGRAMMABLE
}

union TransactionBlockKind =
    ConsensusCommitPrologueTransaction
  | GenesisTransaction
  | ChangeEpochTransaction
  | ProgrammableTransactionBlock

type ConsensusCommitPrologueTransaction {
  epoch: Epoch
  # TODO: This is the "leader round" -- does this line up with
  # checkpoints? In which case, it may suffice to have a `Checkpoint`
  # here.
  round: U64
  timestampMs: U64
}

type GenesisTransaction {
  objects: [Object]
}

type ChangeEpochTransaction {
  epoch: Epoch
  timestampMs: U64

  storageCharge: U64
  computationCharge: U64
  storageRebate: U64
}

type ProgrammableTransactionBlock {
  inputs: [TransactionInput]
  transactions: [ProgrammableTransaction]
}

union TransactionInput = MovePackage | MoveObject | ShareInput

type SharedInput {
  id: SuiAddress
  initialSharedVersion: U64
  mutable: Boolean
}

union TransactionArgument = GasCoin | Input | Result

type GasCoin {}
type Input   { ix: Int }
type Result  { cmd: Int, ix: Int }

union ProgrammableTransaction =
    MoveCallTransaction
  | TransferObjectsTransaction
  | SplitCoinTransaction
  | MergeCoinsTransaction
  | PublishTransaction
  | UpgradeTransaction
  | MakeMoveVecTransaction

type MoveCallTransaction {
  moduleId: MoveModuleId
  name: String
  function: NormalizedFunction

  typeArguments: [MoveType]
  arguments: [TransactionArgument]
}

type TransferObjectsTransaction {
  objects: [TransactionArgument]
  address: TransactionArgument
}

type SplitCoinTransaction {
  coin: TransactionArgument
  amounts: [TransactionArgument]
}

type MergeCoinsTransaction {
  coin: TransactionArgument
  coins: [TransactionArgument]
}

type PublishTransaction {
  dependencies: [MovePackage]
}

type UpgradeTransaction {
  dependencies: [MovePackage]
  currentPackage: MovePackage
  upgradeTicket: TransactionArgument
}

type MakeMoveVecTransaction {
  type: MoveType
  elements: [TransactionArgument]
}

# Omitting for brevity -- there's a lot of structure here, but it's
# not very "connected" (i.e. no edges to other types).
type TransactionSignature {}

type TransactionBlockEffects {
  digest: Digest!
  status: ExecutionStatus!
  errors: String
  transactionBlock: TransactionBlock
  dependencies: [TransactionBlock]

  lamportVersion: U64
  gasEffects: GasEffects
  objectReads: [Object]
  objectChanges: [ObjectChange]
  balanceChanges: [BalanceChange]

  epoch: Epoch
  checkpoint: Checkpoint

  events: TransactionEventConnection

  bcs: Bytes
}

enum ExecutionStatus {
  SUCCESS
  FAILURE
}

type GasInput {
  gasSponsor: Address
  gasPayment: [Object]

  gasPrice: U64
  gasBudget: U64
}

type GasEffects {
  gasObject: Coin
  gasSummary: GasCostSummary
}

type GasCostSummary {
  computationCost: U64
  storageCost: U64
  storageRebate: U64
  nonRefundableStorageFee: U64
}

type ObjectChange {
  inputState: Object
  outputState: Object

  idCreated: Boolean
  idDeleted: Boolean
}

type BalanceChange {
  owner: Owner
  coinType: MoveType
  amount: I128
}

type Event {
  moduleId: MoveModuleId
  type: MoveType
  sender: Address
  timestampMs: U64

  json: JSON
  bcs: Bytes
}

type Balance {
  coinType: MoveType
  coinObjectCount: U64
  totalBalance: U128
}

type Coin {
  balance: U64
  asMoveObject: MoveObject
}

type StakedSui {
  status: StakeStatus
  requestEpoch: Epoch
  activeEpoch: Epoch
  principal: U64

  # Only available if status is `ACTIVE`.
  estimatedReward: U64

  asMoveObject: MoveObject
}

enum StakeStatus {
  PENDING
  ACTIVE
  UNSTAKED
}

type CoinMetadata {
  decimals: Int
  name: String
  symbol: String
  description: String
  iconURL: String
  supply: U64

  asMoveObject: MoveObject
}

input DynamicFieldName {
  type: TypeInst!
  bcs: Bytes!
}

type DynamicField {
  name: MoveValue
  value: DynamicFieldValue
}

union DynamicFieldValue = MoveObject | MoveValue

type MoveObject {
  contents: MoveValue
  hasPublicTransfer: Boolean

  asCoin: Coin
  asStakedSui: StakedSui
  asObject: Object
}

type MovePackage {
  modules: MovePackageModuleConnection

  normalizedModules: NormalizedModulesConnection
  normalizedModule(name: String!): NormalizedModule

  asObject: Object
}

type MoveModuleId {
  package: MovePackage
  name: String
}

enum MoveAbility {
  COPY
  DROP
  STORE
  KEY
}

enum MoveVisibility {
  PUBLIC
  PRIVATE
  FRIEND
}

enum MoveReference {
  IMMUT
  MUT
}

type MoveStructTypeParameterDecl {
  constraints: [MoveAbility]
  isPhantom: Boolean
}

type MoveFunctionTypeParameterDecl {
  constraints: [MoveAbility]
}

type NormalizedModule {
  fileFormatVersion: Int

  moduleId: MoveModuleId
  friends: [MoveModuleId]

  structs: NormalizedStructConnection
  struct(name: String!): NormalizedStruct

  functions: NormalizedFunctionConnection
  function(name: String!): NormalizedFunction
}

type NormalizedStruct {
  module: NormalizedModule
  name: String

  abilities: [MoveAbility]
  typeParameters: [MoveStructTypeParameterDecl]
  fields: [NormalizedField]
}

type NormalizedField {
  name: String
  type: MoveTypeUse
}

type NormalizedFunction {
  module: NormalizedModule
  name: String

  visibility: MoveVisibility
  isEntry: Boolean

  typeParameters: [MoveFunctionTypeParameterDecl]
  parameters: [MoveTypeUse]
  return: [MoveTypeUse]
}

type MoveValue {
  type: MoveType!
  data: MoveData

  bcs: Bytes
}

union MoveData =
    MoveNumber
  | MoveBool
  | MoveAddress
  | MoveUID
  | MoveString
  | MoveVector
  | MoveOption
  | MoveStruct

type MoveNumber  { number: String! }
type MoveBool    { bool: Boolean! }
type MoveAddress { address: SuiAddress! }
type MoveUID     { uid: SuiAddress! }
type MoveString  { string: String! }
type MoveVector  { elements: [MoveValue!]! }
type MoveOption  { element: MoveValue }
type MoveStruct  { fields: [MoveField!]! }

type MoveField {
  name: String!
  value: MoveValue!
}

type MoveTypeName {
  # Fully qualified type name.  Primitive types have no `moduleId`, or
  # `struct`.
  moduleId: MoveModuleId
  name: String!
  struct: NormalizedStruct
}

type MoveType {
  # Scalar representation of the type instantiation (type and type
  # parameters)
  repr: TypeInst!
  typeName: MoveTypeName!
  typeParameters: [MoveType]
}

type MoveTypeUse {
  # Scalar representation of the use of a type in a signature.
  repr: TypeSignature!
  ref: MoveReference
  type: MoveTypeBody
}

union MoveTypeBody = MoveTypeNameUse | MoveTypeParameterUse

type MoveTypeNameUse {
  name: MoveTypeName!
  typeParameters: [MoveTypeUse]
}

type MoveTypeParameterUse {
  index: Int
}

# Metrics (omitted for brevity)
type NetworkMetrics {}
type MoveCallMetrics {}
type AddressMetrics {}

# Connections

type AddressMetricConnection {}
type BalanceConnection {}
type CheckpointConnection {}
type CoinConnection {}
type DynamicFieldConnection {}
type EventQueryConnection {}
type MovePackageModuleConnection {}
type NameServiceNamesConnection {}
type NormalizedFunctionConnection {}
type NormalizedModuleConnection {}
type NormalizedStructConnection {}
type ObjectQueryConnection {}
type StakeConnection {}
type TransactionBlockConnection {}
type TransactionBlockQueryConnection {}
type TransactionEventConnection {}
