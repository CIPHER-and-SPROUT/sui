{
    "data": "/// Example of a game character with basic attributes, inventory, and\n/// associated logic.\nmodule Examples::Hero {\n    use Examples::TrustedCoin::EXAMPLE;\n    use FastX::Address::{Self, Address};\n    use FastX::Coin::{Self, Coin};\n    use FastX::Event;\n    use FastX::ID::{Self, ID, IDBytes};\n    use FastX::Math;\n    use FastX::Transfer;\n    use FastX::TxContext::{Self, TxContext};\n    use Std::Option::{Self, Option};\n\n    /// Our hero!\n    struct Hero has key, store {\n        id: ID,\n        /// Hit points. If they go to zero, the hero can't do anything\n        hp: u64,\n        /// Experience of the hero. Begins at zero\n        experience: u64,\n        /// The hero's minimal inventory\n        sword: Option<Sword>,\n    }\n\n    /// The hero's trusty sword\n    struct Sword has key, store {\n        id: ID,\n        /// Constant set at creation. Acts as a multiplier on sword's strength.\n        /// Swords with high magic are rarer (because they cost more).\n        magic: u64,\n        /// Sword grows in strength as we use it\n        strength: u64,\n    }\n\n    /// For healing wounded heroes\n    struct Potion has key, store {\n        id: ID,\n        /// Effectivenss of the potion\n        potency: u64\n    }\n\n    /// A creature that the hero can slay to level up\n    struct Boar has key {\n        id: ID,\n        /// Hit points before the boar is slain\n        hp: u64,\n        /// Strength of this particular boar\n        strength: u64\n    }\n\n    /// Capability conveying the authority to create boars and potions\n    struct GameAdmin has key {\n        id: ID,\n        /// Total number of boars the admin has created\n        boars_created: u64,\n        /// Total number of potions the admin has created\n        potions_created: u64\n    }\n\n    /// Event emitted each time a Hero slays a Boar\n    struct BoarSlainEvent has copy, drop {\n        /// Address of the user that slayed the boar\n        slayer_address: Address,\n        /// ID of the Hero that slayed the boar\n        hero: IDBytes,\n        /// ID of the now-deceased boar\n        boar: IDBytes,\n    }\n\n    /// Address of the admin account that receives payment for swords\n    const ADMIN: vector<u8> = vector[189, 215, 127, 86, 129, 189, 1, 4, 90, 106, 17, 10, 123, 200, 40, 18, 34, 173, 240, 91, 213, 72, 183, 249, 213, 210, 39, 181, 105, 254, 59, 163];\n    /// Upper bound on player's HP\n    const MAX_HP: u64 = 1000;\n    /// Upper bound on how magical a sword can be\n    const MAX_MAGIC: u64 = 10;\n    /// Minimum amount you can pay for a sword\n    const MIN_SWORD_COST: u64 = 100;\n\n    // TODO: proper error codes\n    /// The boar won the battle\n    const EBOAR_WON: u64 = 0;\n    /// The hero is too tired to fight\n    const EHERO_TIRED: u64 = 1;\n    /// Trying to initialize from a non-admin account\n    const ENOT_ADMIN: u64 = 2;\n    /// Not enough money to purchase the given item\n    const EINSUFFICIENT_FUNDS: u64 = 3;\n    /// Trying to remove a sword, but the hero does not have one\n    const ENO_SWORD: u64 = 4;\n    /// Assertion errors for testing\n    const ASSERT_ERR: u64 = 5;\n\n    // --- Initialization\n\n    /// Create the `GameAdmin` capability and hand it off to the admin\n    /// authenticator\n    fun init(ctx: &mut TxContext) {\n        let admin = admin();\n        // ensure this is being initialized by the expected admin authenticator\n        assert!(&TxContext::get_signer_address(ctx) == &admin, ENOT_ADMIN);\n        Transfer::transfer(\n            GameAdmin {\n                id: TxContext::new_id(ctx),\n                boars_created: 0,\n                potions_created: 0\n            },\n            admin\n        )\n    }\n\n    // --- Gameplay ---\n\n    /// Slay the `boar` with the `hero`'s sword, get experience.\n    /// Aborts if the hero has 0 HP or is not strong enough to slay the boar\n    public fun slay(hero: &mut Hero, boar: Boar, ctx: &mut TxContext) {\n        let Boar { id: boar_id, strength: boar_strength, hp } = boar;\n        let hero_strength = hero_strength(hero);\n        let boar_hp = hp;\n        let hero_hp = hero.hp;\n        // attack the boar with the sword until its HP goes to zero\n        while (boar_hp > hero_strength) {\n            // first, the hero attacks\n            boar_hp = boar_hp - hero_strength;\n            // then, the boar gets a turn to attack. if the boar would kill\n            // the hero, abort--we can't let the boar win!\n            assert!(hero_hp >= boar_strength , EBOAR_WON);\n            hero_hp = hero_hp - boar_strength;\n\n        };\n        // hero takes their licks\n        hero.hp = hero_hp;\n        // hero gains experience proportional to the boar, sword grows in\n        // strength by one (if hero is using a sword)\n        hero.experience = hero.experience + hp;\n        if (Option::is_some(&hero.sword)) {\n            level_up_sword(Option::borrow_mut(&mut hero.sword), 1)\n        };\n        // let the world know about the hero's triumph by emitting an event!\n        Event::emit(BoarSlainEvent {\n            slayer_address: TxContext::get_signer_address(ctx),\n            hero: *ID::get_inner(&hero.id),\n            boar: *ID::get_inner(&boar_id),\n        });\n        ID::delete(boar_id);\n\n    }\n\n    /// Strength of the hero when attacking\n    public fun hero_strength(hero: &Hero): u64 {\n        // a hero with zero HP is too tired to fight\n        if (hero.hp == 0) {\n            return 0\n        };\n\n        let sword_strength = if (Option::is_some(&hero.sword)) {\n            sword_strength(Option::borrow(&hero.sword))\n        } else {\n            // hero can fight without a sword, but will not be very strong\n            0\n        };\n        // hero is weaker if he has lower HP\n        (hero.experience * hero.hp) + sword_strength\n    }\n\n    fun level_up_sword(sword: &mut Sword, amount: u64) {\n        sword.strength = sword.strength + amount\n    }\n\n    /// Strength of a sword when attacking\n    public fun sword_strength(sword: &Sword): u64 {\n        sword.magic + sword.strength\n    }\n\n    // --- Inventory ---\n\n    /// Heal the weary hero with a potion\n    public fun heal(hero: &mut Hero, potion: Potion) {\n        let Potion { id, potency } = potion;\n        ID::delete(id);\n        let new_hp = hero.hp + potency;\n        // cap hero's HP at MAX_HP to avoid int overflows\n        hero.hp = Math::min(new_hp, MAX_HP)\n    }\n\n    /// Add `new_sword` to the hero's inventory and return the old sword\n    /// (if any)\n    public fun equip_sword(hero: &mut Hero, new_sword: Sword): Option<Sword> {\n        Option::swap_or_fill(&mut hero.sword, new_sword)\n    }\n\n    /// Disarm the hero by returning their sword.\n    /// Aborts if the hero does not have a sword.\n    public fun remove_sword(hero: &mut Hero): Sword {\n        assert!(Option::is_some(&hero.sword), ENO_SWORD);\n        Option::extract(&mut hero.sword)\n    }\n\n    // --- Object creation ---\n\n    /// It all starts with the sword. Anyone can buy a sword, and proceeds go\n    /// to the admin. Amount of magic in the sword depends on how much you pay\n    /// for it.\n    public fun create_sword(\n        payment: Coin<EXAMPLE>,\n        ctx: &mut TxContext\n    ): Sword {\n        let value = Coin::value(&payment);\n        // ensure the user pays enough for the sword\n        assert!(value >= MIN_SWORD_COST, EINSUFFICIENT_FUNDS);\n        // pay the admin for ths sword\n        Transfer::transfer(payment, admin());\n\n        // magic of the sword is proportional to the amount you paid, up to\n        // a max. one can only imbue a sword with so much magic\n        let magic = (value - MIN_SWORD_COST) / MIN_SWORD_COST;\n        Sword {\n            id: TxContext::new_id(ctx),\n            magic: Math::min(magic, MAX_MAGIC),\n            strength: 1\n        }\n    }\n\n    public fun acquire_hero(payment: Coin<EXAMPLE>, ctx: &mut TxContext) {\n        let sword = create_sword(payment, ctx);\n        let hero = create_hero(sword, ctx);\n        Transfer::transfer(hero, TxContext::get_signer_address(ctx))\n    }\n\n    /// Anyone can create a hero if they have a sword. All heros start with the\n    /// same attributes.\n    public fun create_hero(sword: Sword, ctx: &mut TxContext): Hero {\n        Hero {\n            id: TxContext::new_id(ctx),\n            hp: 100,\n            experience: 0,\n            sword: Option::some(sword),\n        }\n    }\n\n    /// Admin can create a potion with the given `potency` for `recipient`\n    public fun send_potion(\n        potency: u64,\n        player: Address,\n        admin: &mut GameAdmin,\n        ctx: &mut TxContext\n    ) {\n        admin.potions_created = admin.potions_created + 1;\n        // send potion to the designated player\n        Transfer::transfer(\n            Potion { id: TxContext::new_id(ctx), potency },\n            player\n        )\n    }\n\n    /// Admin can create a boar with the given attributes for `recipient`\n    public fun send_boar(\n        admin: &mut GameAdmin,\n        hp: u64,\n        strength: u64,\n        player: vector<u8>,\n        ctx: &mut TxContext\n    ) {\n        admin.boars_created = admin.boars_created + 1;\n        // send boars to the designated player\n        Transfer::transfer(\n            Boar { id: TxContext::new_id(ctx), hp, strength },\n            Address::new(player)\n        )\n    }\n\n    fun admin(): Address {\n        Address::new(ADMIN)\n    }\n\n    // --- Testing functions ---\n    fun assert_hero_strength(hero: &Hero, strength: u64, _: &mut TxContext) {\n        assert!(hero_strength(hero) == strength, ASSERT_ERR);\n    }\n\n}\n"
}
