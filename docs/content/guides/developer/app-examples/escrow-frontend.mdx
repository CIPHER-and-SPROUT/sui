---
title: Escrow Frontend
draft: true
---

This is a continuation of the Escrow smart contract guide to demonstrate how to build a frontend (UI) allowing end-users to discover trades and interact with listed escrows.

## Prerequisites

:::info

The full source code for the frontend available at the [Trading Frontend example directory](https://github.com/MystenLabs/sui/examples/trading/frontend).

:::

Before getting started, make sure you:

- Understand [the mechanism behind the Escrow smart contract backend](/guides/developer/app-examples/escrow).
- Check out [indexing service guide](/guides/developer/app-examples/escrow-indexer-api) to learn how we index on-chain data and API endpoints exposed to serve data query requests.
- Install [`pnpm` through this guide](https://pnpm.io/installation) as we will use it as our package manager.
- Check out [Sui Typescript SDK](https://sdk.mystenlabs.com/typescript) for basic usage on how to interact with Sui with Typescript.
- Check out [Sui dApp Kit](https://sdk.mystenlabs.com/dapp-kit) to learn basic building blocks for developing a dApp in the Sui ecosystem with React.js.
- Check out [React Router](https://reactrouter.com/en/main) as we use it to navigate between different routes in our UI website.
- `dApp Kit` provides a set of hooks for making query and mutation calls to Sui blockchain. These hooks are thin wrappers around query and mutation hooks from `@tanstack/react-query`. Please check out [@tanstack/react-query](https://tanstack.com/query/latest/docs/framework/react/overview) to learn the basic usage for managing, caching, mutating server state.
- This project is bootstrapped through `pnpm create @mysten/dapp`. Please check out [@mysten/create-dapp](https://sdk.mystenlabs.com/dapp-kit/create-dapp) for how to scaffold a React.js Sui dApp project quickly.

## Frontend

Let's start with the UI wireframe.

Our UI design consists of three parts:

- A header containing the button allowing users to connect their wallet and navigate to other pages.
- A place for users to manage their owned objects to be ready for escrow trading called `Manage Objects`.
- A place for users to discover, create, execute trades called `Escrows`.

:::warning

The code snippets below are not the full source code, they are just part of the code that are relevant logic to what we want to focus on.

:::

### Setup Providers

We need to set up and configure several providers at the root of our React.js tree to ensure different libraries including `dApp Kit`, `@tanstack/react-query`, `react-router-dom` work as expected.

```ts title='src/main.tsx'
import { createNetworkConfig, SuiClientProvider, WalletProvider } from '@mysten/dapp-kit';
import { getFullnodeUrl } from '@mysten/sui.js/client';
import { Theme } from '@radix-ui/themes';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { RouterProvider } from 'react-router-dom';

import { router } from '@/routes/index.tsx';

const queryClient = new QueryClient();

const { networkConfig } = createNetworkConfig({
	localnet: { url: getFullnodeUrl('localnet') },
	devnet: { url: getFullnodeUrl('devnet') },
	testnet: { url: getFullnodeUrl('testnet') },
	mainnet: { url: getFullnodeUrl('mainnet') },
});

ReactDOM.createRoot(document.getElementById('root')!).render(
	<React.StrictMode>
		<Theme appearance="light">
			<QueryClientProvider client={queryClient}>
				<SuiClientProvider networks={networkConfig} defaultNetwork="testnet">
					<WalletProvider autoConnect>
						<RouterProvider router={router} />
					</WalletProvider>
				</SuiClientProvider>
			</QueryClientProvider>
		</Theme>
	</React.StrictMode>,
);
```

### Connect Wallet

`dApp Kit` comes with a pre-built React.js component called `ConnectButton` displaying a button to connect and disconnect a wallet. The connecting and disconnecting wallet logic is handled seamlessly so you don't need to worry about repeating yourself doing the same logic all over again.

We will place the `ConnectButton` in the header

```ts title='src/components/Header.tsx'
import { ConnectButton } from '@mysten/dapp-kit';
import { Box, Button, Container, Flex, Heading } from '@radix-ui/themes';

export function Header() {
	return (
		<Container>
			<Box className="connect-wallet-wrapper">
				<ConnectButton />
			</Box>
		</Container>
	);
}
```

### Execute Transaction Hook

In our frontend, we may need to execute a transaction block in multiple places, hence, it's better to extract the transaction execution logic and reuse it everywhere. Let's examine the execute transaction hook.

```ts title='src/hooks/useTransactionExecution.ts'
import { useSignTransactionBlock, useSuiClient } from '@mysten/dapp-kit';
import { SuiTransactionBlockResponse } from '@mysten/sui.js/client';
import { TransactionBlock } from '@mysten/sui.js/transactions';
import toast from 'react-hot-toast';

export function useTransactionExecution() {
	const client = useSuiClient();
	const { mutateAsync: signTransactionBlock } = useSignTransactionBlock();

	const executeTransaction = async (
		txb: TransactionBlock,
	): Promise<SuiTransactionBlockResponse | void> => {
		try {
			const signature = await signTransactionBlock({
				transactionBlock: txb,
			});

			const res = await client.executeTransactionBlock({
				transactionBlock: signature.transactionBlockBytes,
				signature: signature.signature,
				options: {
					showEffects: true,
					showObjectChanges: true,
				},
			});

			toast.success('Successfully executed transaction!');
			return res;
		} catch (e: any) {
			toast.error(`Failed to execute transaction: ${e.message as string}`);
		}
	};

	return executeTransaction;
}
```

The hook logic is straightforward. We want a `TransactionBlock` as input, we sign it with the current connected wallet account, execute the transaction block, return the execution result and finally display a simple toast message for the end-users to indicate whether the transaction is successful or not.

We use `useSuiClient()` hook from `dApp Kit` to retrieve the Sui client instance we configured in the **Setup Providers** step. `useSignTransactionBlock()` is another hook from `dApp kit` helps us to sign the transaction block using the current connected wallet. It will display the UI for the end-users to review and sign their transactions with their selected wallet. To execute a transaction block, we use a method `executeTransactionBlock()` on the Sui client instance of the Sui Typescript SDK. We use `react-hot-toast` as another dependency to toast transaction status to end-users.

### Generate Demo Data

:::info

The full source code of the demo bear smart contract is available at [Trading Contracts Demo directory](https://github.com/MystenLabs/sui/examples/trading/contracts/demo)

:::

We need an utility function to create a dummy object representing "real world asset" so we can use it to test and demonstrate escrow users flow on the UI directly.

```ts title='src/mutations/demo.ts'
import { useCurrentAccount } from '@mysten/dapp-kit';
import { TransactionBlock } from '@mysten/sui.js/transactions';
import { useMutation, useQueryClient } from '@tanstack/react-query';

import { CONSTANTS } from '@/constants';
import { useTransactionExecution } from '@/hooks/useTransactionExecution';

// SPDX-License-Identifier: Apache-2.0
export function useGenerateDemoData() {
	const account = useCurrentAccount();
	const executeTransaction = useTransactionExecution();
	const queryClient = useQueryClient();

	return useMutation({
		mutationFn: async () => {
			if (!account?.address) throw new Error('You need to connect your wallet!');
			const txb = new TransactionBlock();

			const bear = txb.moveCall({
				target: `${CONSTANTS.demoContract.packageId}::demo_bear::new`,
				arguments: [txb.pure.string(`A happy bear`)],
			});

			txb.transferObjects([bear], txb.pure.address(account.address));

			return executeTransaction(txb);
		},
		onSuccess: () => {
			queryClient.invalidateQueries({
				queryKey: ['getOwnedObjects'],
			});
		},
	});
}
```

As we previously mentioned, we use `@tanstack/react-query` to query, cache and mutate server state. Server state is data only available on remote servers, and the only way to retrieve or update these data is by interacting with these remote servers. In our case, it could be from an API or directly from Sui blockchain RPC.

When we execute a transaction call, we target to mutate the data remotely, specifically on Sui blockchain, hence, we want to use `useMutation()` hook. `useMutation()` hook accepts several inputs, however, in this example, we only need two of them. The first parameter `mutationFn` accepts the function to execute the main mutating logic while the second paramter `onSuccess` is a callback runs when the mutating logic succeeds.

Our main mutating logic is pretty simple, we execute a Move call of a package named `demo_bear::new` to create a dummy bear object and transfer it to the connected wallet account all within the same `TransactionBlock`. We reuse the `executeTransaction()` hook from the **Execute Transaction Hook** step to execute the transaction.

Another benefit of wrapping the main mutating logic inside `useMutation()` is that we can access and manipulate the cache storing server state,fetched from remote servers by using query call, in appropriate callback. In our case, it is `onSuccess` callback. When the transaction succeeds, we want to invalidate the cache data at the cache key called `getOwnedObjects`, then, `@tanstack/react-query` will handle the re-fetching mechanism for the invalidated data automatically. We do this by using `invalidateQueries()` on the `@tanstack/react-query` configured client instance retrieved by `useQueryClient()` hook in the **Setup Providers** step.

Now we have the logic to create a dummy bear object. We just need to attach it into the button in the header.

```ts title='src/components/Header.tsx'
import { useGenerateDemoData } from '@/mutations/demo';

export function Header() {
	const { mutate: demoBearMutation, isPending } = useGenerateDemoData();
	return (
		<Container>
			<Box>
				<Button
					className="cursor-pointer"
					disabled={isPending}
					onClick={() => {
						demoBearMutation();
					}}
				>
					New Demo Bear
				</Button>
			</Box>
		</Container>
	);
}
```

### Locked Dashboard

Recall from our UI design wireframe, we have a tab for users to manage their owned objects to be ready for escrow trading. The code of this tab lives in the file `src/routes/LockedDashBoard.tsx`. In this tab, we will have 2 sub-tabs:

- **My Locked Objects** tab to list out all of owned `Locked` objects.
- **Lock/Unlock Own Objects** tab to lock/unlock owned objects.

#### My Locked Objects

Let's first take a look at the **My Locked Objects** tab by examining `src/components/locked/OwnedLockedList.tsx`. We may want to only focus on the logic on how we retrieve this list.

```ts title='src/components/locked/OwnedLockedList.tsx'
import { useCurrentAccount, useSuiClientInfiniteQuery } from '@mysten/dapp-kit';

import { InfiniteScrollArea } from '@/components/InfiniteScrollArea';
import { CONSTANTS } from '@/constants';

import { LockedObject } from './LockedObject';

export function OwnedLockedList() {
	const account = useCurrentAccount();
	const { data, isLoading, fetchNextPage, hasNextPage, isFetchingNextPage } =
		useSuiClientInfiniteQuery(
			'getOwnedObjects',
			{
				filter: {
					StructType: CONSTANTS.escrowContract.lockedType,
				},
				owner: account?.address!,
				options: {
					showContent: true,
					showOwner: true,
				},
			},
			{
				enabled: !!account?.address,
				select: (data) => data.pages.flatMap((page) => page.data),
			},
		);
	return (
		<>
			<InfiniteScrollArea
				loadMore={() => fetchNextPage()}
				hasNextPage={hasNextPage}
				loading={isFetchingNextPage || isLoading}
			>
				{data?.map((item) => <LockedObject key={item.data?.objectId} object={item.data!} />)}
			</InfiniteScrollArea>
		</>
	);
}
```

We will fetch the owned `Locked` objects directly from Sui blockchain using `useSuiClientInfiniteQuery()` hook from `dApp Kit`. This hook is a thin wrapper around Sui blockchain RPC calls, reference the documentation to learn more about these [RPC hooks](https://sdk.mystenlabs.com/dapp-kit/rpc-hooks). Basically, you need to supply the RPC endpoint you want to execute, in our case, it is [`getOwnedObjects` endpoint](https://docs.sui.io/sui-api-ref#suix_getownedobjects). We need to supply the connected wallet account and the `Locked` object struct type to the call. The struct type is usually identified by the format of `{PACKAGE_ID}::{{MODULE_NAME}}::{{STRUCT_TYPE}}`. The returned data will be stored inside the cache at query key `getOwnedObjects`. Recall the previous section where we invalidate the data at this key after the mutation succeeds, the `useSuiClientInfiniteQuery()` hook will automatically re-fetch the data, thus, we don't have to worry about the out-dated data living in our frontend application.

The `LockedObject` component allows us to display data of the `Locked` wrapper object. However, we also need to display the wrapped or original object as well. Recall from the smart contract, the original object is stored in a dynamic object field. We can use `dApp Kit` to make the RPC `getDynamicFieldObject` call to query about the child object details.

```ts title='src/components/locked/LockedObject.tsx'
// Get the itemID for the locked object (We've saved it as a DOF on the SC).
const suiObjectId = useSuiClientQuery(
	'getDynamicFieldObject',
	{
		parentId: object.objectId,
		name: {
			type: CONSTANTS.escrowContract.lockedObjectDFKey,
			value: {
				dummy_field: false,
			},
		},
	},
	{
		select: (data) => data.data,
		enabled: !itemId,
	},
);
```

#### Lock/Unlock Owned Objects

Next, let's take a look at the **Lock/Unlock Owned Objects** tab. To lock/unlock the owned object, we need to execute corresponding Move calls to the smart contract `lock` module. Hence, we need new mutation functions to handle these logic.

To lock the object, we need to execute the `lock` Move function identified by `{PACKAGE_ID}::lock::lock`. The implementation is similar to what we see in previous mutation functions, we use `useMutation()` from `@tanstack/react-query` wrap the main logic inside it. Our lock function requires an object to be locked and its type since our smart contract `lock` function is generic and requires type parameters. After a `Locked` object and its `Key` are created, we need to transfer them to the connected wallet account within the same transaction block.

```ts title='src/mutations/locked.ts'
export function useLockObjectMutation() {
	const account = useCurrentAccount();
	const executeTransaction = useTransactionExecution();

	return useMutation({
		mutationFn: async ({ object }: { object: SuiObjectData }) => {
			if (!account?.address) throw new Error('You need to connect your wallet!');
			const txb = new TransactionBlock();

			const [locked, key] = txb.moveCall({
				target: `${CONSTANTS.escrowContract.packageId}::lock::lock`,
				arguments: [txb.object(object.objectId)],
				typeArguments: [object.type!],
			});

			txb.transferObjects([locked, key], txb.pure.address(account.address));

			return executeTransaction(txb);
		},
	});
}
```

To unlock the object, we need to execute the `unlock` Move function identified by `{PACKAGE_ID}::lock::unlock`. The implementation is straightforward, we call the `unlock` function supplying the `Locked` object, its corresponding `Key`, the struct type of the original object and transfer the unlocked object to the current connected wallet account. We also implement `onSuccess` callback to invalidate the cache data at query key `locked` after 1 second to force `react-query` to re-fetch the data at corresponding key automatically.

```ts title='src/mutations/locked.ts'
export function useUnlockMutation() {
	const account = useCurrentAccount();
	const executeTransaction = useTransactionExecution();
	const client = useSuiClient();
	const queryClient = useQueryClient();

	return useMutation({
		mutationFn: async ({
			lockedId,
			keyId,
			suiObject,
		}: {
			lockedId: string;
			keyId: string;
			suiObject: SuiObjectData;
		}) => {
			if (!account?.address) throw new Error('You need to connect your wallet!');
			const key = await client.getObject({
				id: keyId,
				options: {
					showOwner: true,
				},
			});

			if (
				!key.data?.owner ||
				typeof key.data.owner === 'string' ||
				!('AddressOwner' in key.data.owner) ||
				key.data.owner.AddressOwner !== account.address
			) {
				toast.error('You are not the owner of the key');
				return;
			}

			const txb = new TransactionBlock();

			const item = txb.moveCall({
				target: `${CONSTANTS.escrowContract.packageId}::lock::unlock`,
				typeArguments: [suiObject.type!],
				arguments: [txb.object(lockedId), txb.object(keyId)],
			});

			txb.transferObjects([item], txb.pure.address(account.address));

			return executeTransaction(txb);
		},
		onSuccess: () => {
			setTimeout(() => {
				// invalidating the queries after a small latency
				// because the indexer works in intervals of 1s.
				// if we invalidate too early, we might not get the latest state.
				queryClient.invalidateQueries({
					queryKey: [QueryKey.Locked],
				});
			}, 1_000);
		},
	});
}
```

Now, we just need to assemble all the logic pieces in the UI at `src/components/locked/LockOwnedObjects.tsx`. We use the same `useSuiClientInfiniteQuery` hook to query all the owned objects of the connected wallet, however, we filter out objects that do not exist the Object Display `display.data.image_url`. Lastly, we use the utility lock/unlock function from `useLockObjectMutation` and `useUnlockMutation` hooks above whenenver the lock/unlock button is clicked.

```ts title='src/components/locked/LockOwnedObjects.tsx'
export function LockOwnedObjects() {
	const account = useCurrentAccount();

	const { mutate: lockObjectMutation, isPending } = useLockObjectMutation();

	const { data, fetchNextPage, isFetchingNextPage, hasNextPage, refetch } =
		useSuiClientInfiniteQuery(
			'getOwnedObjects',
			{
				owner: account?.address!,
				options: {
					showDisplay: true,
					showType: true,
				},
			},
			{
				enabled: !!account,
				select: (data) =>
					data.pages
						.flatMap((page) => page.data)
						.filter((x) => !!x.data?.display && !!x.data?.display?.data?.image_url),
			},
		);

	return (
		<InfiniteScrollArea
			loadMore={() => fetchNextPage()}
			hasNextPage={hasNextPage}
			loading={isFetchingNextPage}
		>
			{data?.map((obj) => (
				<SuiObjectDisplay object={obj.data!}>
					<div className="text-right flex items-center justify-between">
						<p className="text-sm">Lock the item so it can be used for escrows.</p>
						<Button
							className="cursor-pointer"
							disabled={isPending}
							onClick={() => {
								lockObjectMutation(
									{ object: obj.data! },
									{
										onSuccess: () => refetch(),
									},
								);
							}}
						>
							<LockClosedIcon />
							Lock Item
						</Button>
					</div>
				</SuiObjectDisplay>
			))}
		</InfiniteScrollArea>
	);
}
```

### Escrow Dashboard

Recall from our UI design wireframe, we have a place for users to discover, create, execute trades. The code of this tab lives in the file `src/routes/EscrowDashboard.tsx`. In this tab, we will have 3 sub-tabs:

- **Requested Escrows** tab to list out all of the escrow requested for our locked objects.
- **Browse Locked Objects** tab to browse locked objects we can trade for.
- **My Pending Requests** tab to browse escrows we have initiated for third party locked objects.

#### Requested Escrows

Let's take a look at **Requested Escrows** tab by examining `src/components/escrows/EscrowList.tsx`. This time, the data is retrieved by using `useInfiniteQuery` directly from `react-query` as we fetch the data by calling the API service which we already implemented in the [Escrow Indexing and API Service Guide](/guides/developer/app-examples/escrow-indexer-api). We will call the `/escrows` endpoint to fetch all the escrows requested to us.

```ts title='src/components/escrows/EscrowList.tsx'
import { constructUrlSearchParams, getNextPageParam } from '@/utils/helpers';

const { data, fetchNextPage, hasNextPage, isLoading, isFetchingNextPage } = useInfiniteQuery({
	initialPageParam: null,
	queryKey: [QueryKey.Escrow, params, escrowId],
	queryFn: async ({ pageParam }) => {
		const data = await fetch(
			CONSTANTS.apiEndpoint +
				'escrows' +
				constructUrlSearchParams({
					...params,
					...(pageParam ? { cursor: pageParam as string } : {}),
					...(escrowId ? { objectId: escrowId } : {}),
				}),
		);
		return data.json();
	},
	select: (data) => data.pages.flatMap((page) => page.data),
	getNextPageParam,
});
```

#### Accept/Cancel Escrows

To accept or cancel escrows requested for our owned locked objects, we need to implement mutations for these actions.

To accept the escrow, we create a mutation through `useAcceptEscrowMutation` hook in `src/mutations/escrow.ts` file. The implementation should be fairly familiar to you now. The accept function accepts the escrow `ApiEscrowObject` and the locked object `ApiLockedObject`. The `{PACKAGE_ID}::shared::swap` Move call is generic, thus, requires the type parameters of the escrowed and locked objects. We can query the objects details by using `multiGetObjects` on Sui client instance. Lastly, we execute the `{PACKAGE_ID}::shared::swap` Move call and transfer the returned escrowed item to the the connected wallet account. When the mutation suceeds, we also invalidates the cache to allow automatic re-fetch of the data.

```ts title='src/mutations/escrow.ts'
import { ApiEscrowObject, ApiLockedObject } from '@/types/types';

export function useAcceptEscrowMutation() {
	const currentAccount = useCurrentAccount();
	const client = useSuiClient();
	const executeTransaction = useTransactionExecution();
	const queryClient = useQueryClient();

	return useMutation({
		mutationFn: async ({
			escrow,
			locked,
		}: {
			escrow: ApiEscrowObject;
			locked: ApiLockedObject;
		}) => {
			if (!currentAccount?.address) throw new Error('You need to connect your wallet!');
			const txb = new TransactionBlock();

			const escrowObject = await client.multiGetObjects({
				ids: [escrow.itemId, locked.itemId],
				options: {
					showType: true,
				},
			});

			const escrowType = escrowObject.find((x) => x.data?.objectId === escrow.itemId)?.data?.type;

			const lockedType = escrowObject.find((x) => x.data?.objectId === locked.itemId)?.data?.type;

			if (!escrowType || !lockedType) {
				throw new Error('Failed to fetch types.');
			}

			const item = txb.moveCall({
				target: `${CONSTANTS.escrowContract.packageId}::shared::swap`,
				arguments: [
					txb.object(escrow.objectId),
					txb.object(escrow.keyId),
					txb.object(locked.objectId),
				],
				typeArguments: [escrowType, lockedType],
			});

			txb.transferObjects([item], txb.pure.address(currentAccount.address));

			return executeTransaction(txb);
		},

		onSuccess: () => {
			setTimeout(() => {
				queryClient.invalidateQueries({ queryKey: [QueryKey.Escrow] });
			}, 1_000);
		},
	});
}
```

To cancel the escrow, we create a mutation through `useCancelEscrowMutation` hook in `src/mutations/escrow.ts` file. The implementation should be fairly obvious to you now. The cancel function accepts the escrow `ApiEscrowObject` and its on-chain data. The `{PACKAGE_ID}::shared::return_to_sender` Move call is generic, thus, requires the type parameters of the escrowed object. Next, we execute `{PACKAGE_ID}::shared::return_to_sender` and transfer the returned escrowed object to the creator of the escrow.

```ts ts title='src/mutations/escrow.ts'
export function useCancelEscrowMutation() {
	const currentAccount = useCurrentAccount();
	const executeTransaction = useTransactionExecution();
	const queryClient = useQueryClient();

	return useMutation({
		mutationFn: async ({
			escrow,
			suiObject,
		}: {
			escrow: ApiEscrowObject;
			suiObject: SuiObjectData;
		}) => {
			if (!currentAccount?.address) throw new Error('You need to connect your wallet!');
			const txb = new TransactionBlock();

			const item = txb.moveCall({
				target: `${CONSTANTS.escrowContract.packageId}::shared::return_to_sender`,
				arguments: [txb.object(escrow.objectId)],
				typeArguments: [suiObject?.type!],
			});

			txb.transferObjects([item], txb.pure.address(currentAccount?.address!));

			return executeTransaction(txb);
		},

		onSuccess: () => {
			setTimeout(() => {
				queryClient.invalidateQueries({ queryKey: [QueryKey.Escrow] });
			}, 1_000);
		},
	});
}
```

`Escrow` component displays the details of an `ApiEscrowObject` escrow. We first need to query the escrow information directly from Sui blockchain by using `useSuiClientQuery('getObject')`, fetch the `Locked` object details from the API service by using `useQuery` of `react-query`, fetch the on-chain data of the `Locked` object. Now we have all the neccessary information to display the escrow on the UI.

```ts title='src/components/escrows/Escrow.tsx'
export function Escrow({ escrow }: { escrow: ApiEscrowObject }) {
	const account = useCurrentAccount();
	const [isToggled, setIsToggled] = useState(true);
	const { mutate: acceptEscrowMutation, isPending } = useAcceptEscrowMutation();
	const { mutate: cancelEscrowMutation, isPending: pendingCancellation } =
		useCancelEscrowMutation();

	const suiObject = useSuiClientQuery('getObject', {
		id: escrow?.itemId,
		options: {
			showDisplay: true,
			showType: true,
		},
	});

	const lockedData = useQuery({
		queryKey: [QueryKey.Locked, escrow.keyId],
		queryFn: async () => {
			const res = await fetch(`${CONSTANTS.apiEndpoint}locked?keyId=${escrow.keyId}`);
			return res.json();
		},
		select: (data) => data.data[0],
		enabled: !escrow.cancelled,
	});

	const { data: suiLockedObject } = useGetLockedObject({
		lockedId: lockedData.data?.objectId,
	});

	...
}
```

Last but not least, we now have accept and cancel escrows functions, we can use it to fullfil corresponding UI logic in the `src/components/escrows/Escrow.tsx`.

#### Browse Locked Objects