---
title: Sponsored Transaction
draft: true
---

The article gives an overview of Sponsored Transaction, a native feature on Sui blockchain that allows a transaction to be executed without user paying the Gas. It also dicusses the roles in Sponsored Transaction, and a few common use cases. Then it discusses the flow of Sponsored Transaction, mostly for deverlopers who are interested in building a Gas Station or integrate with one. Finally it talks about risk considerations of Sponsored Transaction.

# Overview
A transaction on Sui takes a payment to execute. The payment, also known as Gas, is a list of `0x2::coin::Coin<0x2::sui::Sui>` objects, and paid to Sui Validators to secure the network. Although Gas is a critical piece in Sui tokenomics, it sometimes adds challenges when new users start to navigate on Sui, especially for web2 users.

Sponsored Transaction, initially proposed in issue [#2418](https://github.com/MystenLabs/sui/issues/2418), is a native feature on Sui blockchain  that massively reduces the onboarding friction for users, by allowing to execute a transaction without the user paying the Gas by themselves. Instead, the transaction is paid by the `Sponsor`, who offers their payment gas objects for the transaction.

Natively built in on Sui, Sponsored Transaction is easy to use, composable with all other Sui features and plays an important role in Sui's mission to bring billions of users to web3.

# Roles in Sponsored Transactions
In a Sponsored Tranaction there are 3 roles: the User, the Gas Station and the Sponsor.
* The User is the entity who wants to execute a transaction they like. 
* The Gas Station is the entity that fulfills the sponsorship request for the User's transaction by providing the Gas payment they own.
* The Sponsor is entity that funds the Gas Station for its operations.

It's not uncommon to see the Gas Station and the Sponsor is the same entity. For example, a web3 gaming studio could run its own Gas Station to sponsor users with real "free-to-play" gaming experiences, at its user acquisition stage. As it's not always trivial to maintain a Gas Station for teams of any size, they can leverage third party Gas Stations to sponsor transactions they wish to promote. 

From this point on, we will use "Gas Station" and "Sponsor" interchangeably, unless otherwise specified.

# Use Cases
Below we discuss a few common scenarios where Sponsored Transaction can unleash great potentials.

## App-specific Sponsorship
In this scenario, the Sponsor has a specific set of applications they want to sponsor.
* If the transaction is initialized by the User, the Gas Station/Sponsor would examine the transaction to see it's within that set, before they agree to provide the Gas payment. 
* If the transaction is proposed by the Sponsor - for example a rewards claim transaction of a campaign, or simply a "try it out" advertisement transaction - it is up to the User to decide if they want to finish it off, after examining the transaction.

## Wildcard Sponsorship
In this scenario, the Sponsor has little restrictions on the type of transactions the Gas payment can be used for.
* If the Sponsor is a "gas-less" wallet, it may agree to sponsor any correct transactions proposed by its users.
* In the form of a reward or discount, the Sponsor could offer the User an "wildcard" Gas payment, vocally promising to execute any transactions with that Gas payment.

A Sponsored Transaction is not restricted to the above use cases. Essentially, it is a transaction jointly made by the User and the Sponsor, hence as long as they can use approaches to agree on the transaction details.

However, since at least two stake holders are involved in a Sponsored Transaction, there are some additional risk considerations to be cautious with, discussed in Risk Considerations Section below.


# Sponsored Trasnaction Flow

This section is mostly for developers who are interested in building a Gas Station or integrating with one.

The data structure of a Transaction looks like below:

```rust

pub struct SenderSignedTransaction {
    pub intent_message: IntentMessage<TransactionData>,
    /// A list of signatures signed by all transaction participants.
    /// 1. non participant signature must not be present.
    /// 2. signature order does not matter.
    pub tx_signatures: Vec<GenericSignature>,
}

pub struct TransactionDataV1 {  // <-- A variant of `TransactionData`
    pub kind: TransactionKind,  // <-- This is the actual transaction details
    pub sender: SuiAddress,
    pub gas_data: GasData,
    pub expiration: TransactionExpiration,
}

pub struct GasData {
    pub payment: Vec<ObjectRef>,
    pub owner: SuiAddress,
    pub price: u64,
    pub budget: u64,
}

```

Let's look at a few things:
* `sender` in `TransactionDataV1` (a variant of `TransactionData`) is the User's address
* `gas_data` in `TransactionDataV1` is the Gas payment.
* `GasData` allows a list of Gas objects, but they must be owned by the same address, namely the `owner` in `GasData`, aka the Sponsor. When `owner` is equal to `sender` then this is a regular/non-sponsored transaction.
* `tx_signatures` in `SenderSignedTransaction` is a list of signatures. For a Sponsored Transaction, it needs to contain two signtures, respectively by the User and the Sponsor, whilst order does not matter. The signatures are signed over the entire `TransactionData`, including `GasData`.

So, in order to construct a correct Sponsored Transaction, either a `TransactionData` needs to be built first, then passed to both parties to sign, or one party builds `TransactionData` first, signs it and then passes the transaction and the signature to the other party (e.g. in the form of `SenderSignedTransaction`). In practice, the latter is more common. 

Combining with Use Cases section above, we present three flows of Sponsored Transaction.

**I. User Proposed Transaction**

([swimlane link](https://swimlanes.io/d/wAcnOpA_h))

![](https://static.swimlanes.io/b090340af36c8a4af6c36d4479a4d04f.png)

**II. Sponsor Proposed Transaction**

([swimlane link](https://swimlanes.io/#ZZE9T8QwDIb3/ApvLIWBsQMSEh8DEkI6mInb+O6itk4VOxInxH8nqe76AVki+X392G+iXnuq4fYGdmNgCRHeYhiDkIP3iCzYqg9syuGg2WmstWZMDYjG1Ora9YCK8G0gn2LoPLt6rb/kQjXLQuwo1rBL/t65SCKLdkD5dJlWwzNKwS4SfY0+YsFt2I9zuTI/047mEuj67pKthjmlHj13ki+CD6EIA56gIfCslFfRHN8zIOgyoQJkB2G/pyhZsefNLKDAiKeBWDczC7YG++d97EQ5264ExB8YNUUyZtpjbmyP1Hbb+cX7H7g0PqW+fw0uf5KkZvAKLmE/deU4K9Iv))

![](https://static.swimlanes.io/d917884a263c494bb6127102d0f64840.png)


**III. Wildcard Gas Payment**


([swimlane link](https://static.swimlanes.io/ee3962b3ac3cc5d34f317cecdde125b0.png))

![](https://static.swimlanes.io/ee3962b3ac3cc5d34f317cecdde125b0.png)


# Risk Considerations

## Client Equivocation Risk

Client equivocation happens when more than one legit transactions that share at least one owned object (e.g. a Gas object) at a certain version are submitted to the network simaltaneously. On Sui, before a transaction is executed, owned objects in this transaction are locked on validators at specific versions. A honest validator will only accpet one tranasction and reject others. Depending on the order validators see these transactions, validators may accept different transactions. In the event of no single transaction getting accepted by at least 2/3 of validators, the owned object will be locked until end of the epoch.

Practically speaking, client equivocation is rare, mostly caused by buggy client software. After all, no one has incentives to lock their own objects. However, Sponsored Transaction comes with counterparty risks. For example, a malicious user could equivocate the Gas Station's Gas object by submitting another transaction that uses one owned object in the Gas Station signed transaction at the same version. Similarly, a byzantine Gas Station could do the same to the User owned objects.

Although this risk may sound trivial, it is helpful to be aware of it. Therefore, it is recommended for Gas Station to do monitoring and alerting on abnormal user behaviors. When users using Sponsored Transactions or developers integrating with a Gas station, they should also consider their reputation, to minimize the risk of client equivocation.

A relevant note: both the User and the Sponsor need to sign over the entire `TransactionData`, including `GasData` because otherwise the partially signed data could be snipped by a third party (e.g. a malicious Full node) and cause client equivocation and owned objects locked. 

## Censorship Risk

If the User chooses to submit the dual signed transaction to the Gas Station/Sponsor rather than a FullNode, the tx may be subject to the Gas Station/Sponsor's censorship. Namely, the Gas Station/Sponsor may choose not to submit the transaction to the network, or delay the submission. 

This risk can be mitigated by the User submitting the transaction to a Full Node by themselves.
