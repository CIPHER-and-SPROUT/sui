---
title: Closed Loop Token
---

Closed Loop Token allows its creator to limit applications where the token is used, set up custom policies for transfers, spending and conversions. It is defined in the `sui::token` module and is a part of the Sui Framework.

## Background & Use Cases

The standard Coin implementation on Sui is an example of an open-loop system - Coins are free-flowing, "wrappable", and the best real world analogy would be "cash" - hardly regulated and can be used for any purpose.

However, some applications require constraining the scope of the token to a specific purpose. For example, a token that can only be used for a specific service, or it can be used only by an authorized account, or it can be used freely while account is not blocked. A real-world analogy would be a "bank account" - bank accounts are regulated, controlled by the bank and comply with certain rules and policies.

Specific domains that can benefit from a closed-loop token include:

- **Loyalty Points** - A token that can only be used for a specific service, e.g. for an airline - granted to frequent flyers and used to purchase tickets or upgrades.
- **Regulatory-Compliant Tokens** - some jurisdictions require certain checks or restrictions on tokens. For example, a token that can only be used by a verified user, or a single operation with a token can have a limit.
- **In-Game Currency** - similar to "gems" and "diamonds" in mobile games: a token that can only be used in a game and granted to players for their actions or purchased. Tokens of this kind are often not transferrable and minted in predefined amounts to maintain scarcity and game balance.

## Difference with Coin

Unlike Coin, which has `key + store` abilities and thus supports wrapping and public transfers, Token has only the `key` ability and cannot be wrapped, stored as a dynamic field, or freely transferred (unless there's a custom policy for that).

```move
// defined in `sui::coin`
struct Coin<phantom T> has key, store { id: UID, balance: Balance<T> }

// defined in `sui::token`
struct Token<phantom T> has key { id: UID, balance: Balance<T> }
```

Due to this restriction, Token can only be owned by an account and can't be stored in an application (however, it can be "spent" - see "spending" section).

## Create / Mint & Burn

Token reuses the `TreasuryCap` defined in the `sui::coin` module and therefore has the same initialization process.

```move
module example::my_token {
    use sui::tx_context::{Self, TxContext};
    use sui::transfer;
    use sui::coin;

    /// The One Time Witness and the type of the Coin / Token
    struct MY_TOKEN has drop {}

    // Create the `TreasuryCap` just like you would for a Coin
    fun init(otw: MY_TOKEN, ctx: &mut TxContext) {
        let (treasury_cap, coin_metadata) = coin::create_currency(
            otw, b"MYT", b"My Token", "My Custom Token", std::option::none(), ctx
        );

        transfer::public_freeze_object(coin_metadata);
        transfer::public_transfer(treasury_cap, tx_context::sender(ctx));
    }
}
```

Minting and burning methods are provided by the `sui::token` module; just like with `Coin`, they require the `TreasuryCap` to be passed as an argument.

```move
// module: sui::token

public fun mint<T>(cap: &mut TreasuryCap<T>, amount: u64, ctx: &mut TxContext): Token<T>;

public fun burn<T>(cap: &mut TreasuryCap<T>, token: Token<T>);
```

## Public Actions

Token has a set of public and protected actions which can be used to manage the token. Public actions are available to everyone and don't require any authorization. They have similar APIs to Coin's but operate on the `Token` type:

- `token::keep` - send a Token to the transaction sender
- `token::join` - join two Tokens
- `token::split` - split a Token into two, specify the amount to split
- `token::zero` - create an empty (zero balance) Token
- `token::destroy_zero` - destroy a Token with zero balance

> See Appendix A for Coin and Token methods comparison.

## Protected Actions & Action Request

Some actions are disabled by default. Token creator can enable them by creating a "TokenPolicy" and specifying conditions (Rules) for their execution. In the standard implementation Token has 4 protected functions:

- `token::transfer` - transfer a Token to a recipient (action name: "transfer")
- `token::from_coin` - convert a Coin into a Token (action name: "from_coin")
- `token::to_coin` - convert a Token into a Coin (action name: "to_coin")
- `token::spend` - spend a Token (action name: "spend") - see "Spend Action" for more details

Protected actions are functions that issue an `ActionRequest` - a special hot-potato struct which must be "confirmed" for the transaction to succeed. ActionRequest is defined in the `sui::token` module and contains the following fields:

- `name` - name of the performed action, standard ones are "transfer", "spend", "to_coin" and "from_coin"; and it is possible to create custom ones.
- `amount` - the amount of the token that is being transferred, spent, converted, etc.
- `sender` - the account that initiated the action
- `recipient` - the account that receives the token in "transfer" action (can be used for custom actions)
- `spent_balance` - the balance of a spent Token in the "spend" action (can be utilized in custom actions)

These fields can be used by so-called "Rules" to determine whether the action should be allowed or not. Rules are custom modules which implement restriction logic. See "Rules" section for more details.

An example of a function creating an `ActionRequest`:
```move
// module: sui::token

public fun transfer<T>(t: Token<T>, recipient: address, ctx: &mut TxContext): ActionRequest<T>;
```

## TokenPolicy

A `TokenPolicy` is a shared object which can be created by the Token owner using the TreasuryCap. Here's an example of how a policy can be created (with `transfer` operation allowed):

```js
let tx = new TransactionBlock();
let tokenType = '0x....::my_token::MY_TOKEN';
let treasuryCapArg = tx.object('0x....');

// for each TokenPolicy there's a TokenPolicyCap which allows managing it
let [policy, policyCap] = tx.moveCall({
    target: '0x2::token::new_policy',
    arguments: [ treasuryCapArg ],
    typeArguments: [ tokenType ],
});

// allow `transfer` operation; other operations are disabled
tx.moveCall({
    target: '0x2::token::allow',
    arguments: [ policy, policyCap, tx.pure.string("transfer") ],
    typeArguments: [ tokenType ]
});

tx.transferObjects([ policyCap ], tx.pure.address('0x...sender'));

// policy must be shared with this function
tx.moveCall({
    target: '0x2::token::share_policy',
    arguments: [ policy ],
    typeArguments: [ tokenType ]
});

// submit the transaction
// ...
```

Similarly to `allow` there's a `token::disallow` method which disables the action completely.

## Request Confirmation

There are 2 main ways to confirm an `ActionRequest`:

1. With a `TreasuryCap` - token creator (or an application storing the TreasuryCap) can confirm any request by calling `token::confirm_with_treasury_cap` function. This method is useful for applications that store the TreasuryCap and implement custom logic; it also allows the Token creator to `mint` and `transfer` tokens bypassing the restrictions.
2. With a `TokenPolicy` - token creator can create and share a `TokenPolicy` and set up allowed actions and requirements for each action. This way any application or a wallet would know which actions can be considered "public" and would be able to perform them.

### Confirming with TreasuryCap

TreasuryCap can be used to confirm any ActionRequest for the Token. It's useful for admin actions (eg mint and transfer) as well as for simple applications that don't require a TokenPolicy and wrap the TreasuryCap into the main object.

An example of a transaction implemented in TypeScript with sui.js, confirming an `ActionRequest` with a TreasuryCap. Here the TreasuryCap is owned by the admin account and is used to mint and confirm the transfer request for the token:

```js
let tx = new TransactionBlock();
let tokenType = '0x....::my_token::MY_TOKEN';
let treasuryCapArg = tx.object('0x....');

// mint a 10 tokens using the TreasuryCap
let token = tx.moveCall({
    target: '0x2::token::mint',
    arguments: [ treasuryCapArg, tx.pure.u64(10) ],
    typeArguments: [ tokenType ],
});

// transfer the token to a recipient; receive an `ActionRequest`
let request = tx.moveCall({
    target: '0x2::token::transfer',
    arguments: [ token, tx.pure.address('0x...') ],
    typeArguments: [ tokenType ],
});

// confirm the request with the TreasuryCap
tx.moveCall({
    target: '0x2::token::confirm_with_treasury_cap',
    arguments: [ treasuryCapArg, request ],
    typeArguments: [ tokenType ],
});

// submit the transaction
// ...
```

### Confirming with TokenPolicy

TokenPolicy is a way of enabling certain actions network-wide. Once shared, the TokenPolicy is available to everyone. Hence, it can be used by wallets or any other clients to confirm allowed operations.

An example of a client transfer request confirmation in JavaScript:

```js
let tx = new TransactionBlock();
let tokenType = '0x....::my_token::MY_TOKEN';
let myTokenArg = tx.object('0x...token_object');
let receiverArg = tx.pure.address('0x...receiver');
let tokenPolicyArg = tx.object('0x...token_policy');

let request = tx.moveCall({
    target: '0x2::token::transfer',
    arguments: [ myTokenArg, receiverArg ],
    typeArguments: [ tokenType ],
});

// expecting the `TokenPolicy` to have the `transfer` operation allowed
tx.moveCall({
    target: '0x2::token::confirm_request',
    arguments: [ tokenPolicyArg, request ],
    typeArguments: [ tokenType ],
});

// submit the transaction
// ...
```

## Rules and Restrictions

TokenPolicy can specify custom conditions for each action. These conditions are called "Rules" and are typically implemented as separate Move modules. For most common scenario, a Rule module would contain:

- the Rule type (eg "struct Denylist")
- the verifying function (eg "verify\(\)") that "stamps" the ActionRequest

Here's an example of a Rule module that denies transfers to a specific account:

```move
module examples::blank_rule {
    use sui::token::{Self, TokenPolicy, ActionRequest};
    use sui::tx_context::TxContext;

    /// The type of the Rule, can be specified for any ActionRequest in a TokenPolicy
    struct Blank has drop {}

    /// The function to be called on action
    public fun verify<T>(
        self: &TokenPolicy<T>,
        request: &mut ActionRequest<T>,
        ctx: &mut TxContext
    ) {
        token::add_approval(Blank {}, request, ctx)
    }
}
```

A Rule can be enforced on any action by specifying it in the TokenPolicy:

```js
let tx = new TransactionBlock();
let tokenPolicyArg = tx.object('0x...token_policy');
let tokenPolicyCapArg = tx.object('0x...token_policy_cap');
let tokenType = '0x....::my_token::MY_TOKEN';
let ruleType = '0x....::blank_rule::Blank';

tx.moveCall({
    target: '0x2::token::add_rule_for_action',
    arguments: [
        tokenPolicyArg,
        tokenPolicyCapArg,
        tx.pure.string('transfer'),
    ],
    // Rule is added by its type (ruleType variable)
    typeArguments: [ tokenType, ruleType ],
})

// submit the transaction
// ...
```

Similarly, a Rule can be removed from an action using the `token::remove_rule_for_action` function.

## Appendix A: Coin / Token API comparison

| Function                    | Coin | Token       | Note                                                                             |
|-----------------------------|------|-------------|----------------------------------------------------------------------------------|
| mint                        | +    | +           | Requires TreasuryCap                                                             |
| burn                        | +    | +           | Requires TreasuryCap                                                             |
| join                        | +    | +           | Public                                                                           |
| split                       | +    | +           | Public                                                                           |
| zero                        | +    | +           | Public                                                                           |
| destroy_zero                | +    | +           | Public                                                                           |
| keep                        | -    | +           | Send Token to sender, not required for Coin due to lack of transfer restrictions |
| transfer                    | +    | \[protected] | Coin is transferable by default, Token requires authorization                   |
| to_balance / to_coin        | +    | \[protected] | Token can be converted "to_coin", requires authorization                        |
| from_balance / from_coin    | +    | \[protected] | Token can be created "from_coin", requires authorization                        |
| spend                       | -    | \[protected] | Token can be "spent", requires authorization (see "spending")                   |

## Appendix B: TokenPolicy API

| Function                    | Note                                                                 |
|-----------------------------|----------------------------------------------------------------------|
| new_policy                  | Create a new TokenPolicy using the TreasuryCap                       |
| allow                       | Allow an action in the TokenPolicy                                   |
| disallow                    | Disallow an action in the TokenPolicy                                |
| add_rule_for_action         | Add a Rule for an action in the TokenPolicy                          |
| remove_rule_for_action      | Remove a Rule for an action in the TokenPolicy                       |
| confirm_request             | Confirm an ActionRequest with a TokenPolicy                          |
| confirm_request_mut         | Similar to `confirm_request` but only works for "spend" action       |
